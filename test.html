<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GeoScanner Pro v2.0</title>
    <style>
        :root { --bg: #000; --panel: #111; --accent: #0f0; --text: #eee; --alert: #f00; }
        body {
            margin: 0; background: var(--bg); color: var(--text);
            font-family: 'Consolas', monospace; height: 100vh;
            display: flex; flex-direction: column; overflow: hidden;
        }

        /* --- HUD SUPERIOR --- */
        #hud {
            display: grid; grid-template-columns: 1fr 1fr; gap: 5px;
            padding: 5px; background: var(--panel); border-bottom: 1px solid #333;
            font-size: 0.8rem;
        }
        .hud-box { background: #222; padding: 5px; border-left: 2px solid var(--accent); }
        .label { font-size: 0.7em; color: #888; display: block; }
        .val { font-size: 1.1em; font-weight: bold; }
        .unit { font-size: 0.8em; color: #aaa; }
        .warn { color: var(--alert); border-left-color: var(--alert); animation: blink 0.5s infinite; }

        /* --- ÁREA GRÁFICA --- */
        #viewport { flex-grow: 1; position: relative; background: #000; }
        canvas { display: block; width: 100%; }
        #specCanvas { height: 40%; border-bottom: 1px solid #333; }
        #waterCanvas { height: 60%; }

        /* --- CONTROLES INFERIORES --- */
        #controls {
            display: flex; gap: 10px; padding: 10px;
            background: var(--panel); border-top: 1px solid #333;
        }
        button {
            flex: 1; padding: 15px 0; border: none; border-radius: 4px;
            background: #333; color: white; font-weight: bold; font-size: 0.9rem;
        }
        button.active { background: var(--alert); color: black; }
        button#btn-tare { background: #0066cc; }
        
        /* Overlay Inicial */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 99;
            display: flex; align-items: center; justify-content: center;
        }
        #start-btn {
            padding: 20px 40px; font-size: 1.5rem; background: var(--accent); color: #000;
            border: none; border-radius: 10px; box-shadow: 0 0 20px var(--accent);
        }

        @keyframes blink { 50% { opacity: 0.5; } }
    </style>
</head>
<body>

    <div id="start-screen"><button id="start-btn" onclick="startApp()">LIGAR SISTEMA</button></div>

    <div id="hud">
        <div class="hud-box">
            <span class="label">MAG (DELTA)</span>
            <span id="disp-mag" class="val">--</span> <span class="unit">µT</span>
        </div>
        <div class="hud-box">
            <span class="label">PICO FREQ (VLF)</span>
            <span id="disp-freq" class="val">--</span> <span class="unit">Hz</span>
        </div>
        <div class="hud-box">
            <span class="label">GPS LAT</span>
            <span id="disp-lat" class="val">Buscando...</span>
        </div>
        <div class="hud-box">
            <span class="label">GPS LON</span>
            <span id="disp-lon" class="val">Buscando...</span>
        </div>
        <div class="hud-box" style="grid-column: span 2;">
            <span class="label">STATUS GRAVAÇÃO</span>
            <span id="disp-rec">ESPERA (Total logs: 0)</span>
        </div>
    </div>

    <div id="viewport">
        <canvas id="specCanvas"></canvas>
        <canvas id="waterCanvas"></canvas>
    </div>

    <div id="controls">
        <button id="btn-tare" onclick="tareMag()">TARA (ZERAR)</button>
        <button id="btn-rec" onclick="toggleRecord()">REC (CSV)</button>
        <button onclick="downloadData()">BAIXAR</button>
    </div>

<script>
    // --- CONFIGURAÇÃO ---
    const FFT_SIZE = 4096; // Equilíbrio entre velocidade e resolução
    const SAMPLE_RATE = 48000; // Padrão Android
    
    // --- ESTADO ---
    let state = {
        running: false,
        recording: false,
        magBase: 0, // Valor da Tara
        magCurrent: 0,
        freqPeak: 0,
        vlfLevel: 0,
        gps: { lat: 0, lon: 0, acc: 0 },
        logs: [] // Buffer de dados gravados
    };

    // --- ELEMENTOS ---
    const els = {
        mag: document.getElementById('disp-mag'),
        freq: document.getElementById('disp-freq'),
        lat: document.getElementById('disp-lat'),
        lon: document.getElementById('disp-lon'),
        rec: document.getElementById('disp-rec'),
        btnRec: document.getElementById('btn-rec'),
        cSpec: document.getElementById('specCanvas'),
        cWater: document.getElementById('waterCanvas')
    };
    const ctxSpec = els.cSpec.getContext('2d');
    const ctxWater = els.cWater.getContext('2d');

    // --- AUDIO & SENSORES ---
    let audioCtx, analyser, magSensor;

    async function startApp() {
        document.getElementById('start-screen').style.display = 'none';
        
        // 1. Áudio
        try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });
            const stream = await navigator.mediaDevices.getUserMedia({ 
                audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } 
            });
            const source = audioCtx.createMediaStreamSource(stream);
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = FFT_SIZE;
            source.connect(analyser);
            state.running = true;
            loop();
        } catch(e) { alert("Erro Mic: " + e); }

        // 2. Magnetômetro
        if ('Magnetometer' in window) {
            try {
                magSensor = new Magnetometer({ frequency: 20 });
                magSensor.addEventListener('reading', () => {
                    let raw = Math.sqrt(magSensor.x**2 + magSensor.y**2 + magSensor.z**2);
                    state.magCurrent = raw;
                    // Atualiza HUD
                    let delta = (raw - state.magBase).toFixed(2);
                    els.mag.innerText = (delta > 0 ? "+" : "") + delta;
                    
                    // Alerta visual se anomalia for grande (> 5uT de diferença)
                    if(Math.abs(delta) > 5) els.mag.parentElement.classList.add('warn');
                    else els.mag.parentElement.classList.remove('warn');
                });
                magSensor.start();
            } catch(e) { els.mag.innerText = "Erro Mag"; }
        } else { els.mag.innerText = "Sem Sensor"; }

        // 3. GPS
        if ('geolocation' in navigator) {
            navigator.geolocation.watchPosition(pos => {
                state.gps.lat = pos.coords.latitude.toFixed(6);
                state.gps.lon = pos.coords.longitude.toFixed(6);
                state.gps.acc = pos.coords.accuracy;
                els.lat.innerText = state.gps.lat;
                els.lon.innerText = state.gps.lon;
            }, err => console.log(err), { enableHighAccuracy: true });
        }
    }

    // --- FUNÇÕES DE CONTROLE ---
    function tareMag() {
        state.magBase = state.magCurrent; // Zera o valor atual
    }

    function toggleRecord() {
        state.recording = !state.recording;
        els.btnRec.classList.toggle('active');
        els.btnRec.innerText = state.recording ? "PARAR (REC)" : "REC (CSV)";
    }

    function downloadData() {
        if(state.logs.length === 0) return alert("Nada gravado!");
        
        // Cria CSV
        let csvContent = "data:text/csv;charset=utf-8,TIMESTAMP,LAT,LON,ACCURACY,MAG_RAW,MAG_DELTA,PEAK_FREQ,VLF_LEVEL\n";
        state.logs.forEach(row => {
            csvContent += row.join(",") + "\n";
        });

        // Download
        const encodedUri = encodeURI(csvContent);
        const link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", "geoscan_data_" + Date.now() + ".csv");
        document.body.appendChild(link);
        link.click();
    }

    // --- LOOP PRINCIPAL (VISUALIZAÇÃO) ---
    const bufferLength = FFT_SIZE / 2;
    const dataArray = new Uint8Array(bufferLength);
    
    function loop() {
        if (!state.running) return;
        requestAnimationFrame(loop);

        analyser.getByteFrequencyData(dataArray);

        // Ajuste de Canvas
        const w = els.cSpec.width = els.cSpec.clientWidth;
        const h = els.cSpec.height = els.cSpec.clientHeight;
        const wW = els.cWater.width = els.cWater.clientWidth;
        const hW = els.cWater.height = els.cWater.clientHeight;

        // 1. Processamento de Áudio (Encontrar Pico)
        let maxVal = 0;
        let maxIndex = 0;
        let sum = 0;
        
        ctxSpec.fillStyle = "#000"; ctxSpec.fillRect(0,0,w,h);
        ctxSpec.beginPath(); ctxSpec.strokeStyle = "#0f0"; ctxSpec.lineWidth = 1;

        for(let i = 0; i < bufferLength; i++) {
            let v = dataArray[i];
            
            // Desenhar Linha
            let x = (i / bufferLength) * w;
            let y = h - (v / 255) * h;
            if(i===0) ctxSpec.moveTo(x,y); else ctxSpec.lineTo(x,y);

            // Achar pico (ignorando frequências muito baixas < 100hz ruído elétrico)
            if (i > 10 && v > maxVal) {
                maxVal = v;
                maxIndex = i;
            }
            sum += v;
        }
        ctxSpec.stroke();

        // Calcular Hz do pico
        let nyquist = audioCtx.sampleRate / 2;
        let peakHz = (maxIndex / bufferLength) * nyquist;
        els.freq.innerText = Math.round(peakHz);
        state.freqPeak = Math.round(peakHz);
        state.vlfLevel = Math.floor(sum / bufferLength);

        // 2. Cachoeira (Waterfall) Otimizada
        // Copia a imagem atual 1px para baixo
        ctxWater.drawImage(els.cWater, 0, 0, wW, hW - 1, 0, 1, wW, hW - 1);
        
        // Desenha nova linha no topo
        const imgData = ctxWater.createImageData(wW, 1);
        for(let i = 0; i < wW; i++) {
            // Mapeia pixel X para frequência
            let freqIdx = Math.floor((i / wW) * bufferLength);
            let val = dataArray[freqIdx];
            
            // Mapa de Cores "Inferno" (Preto -> Roxo -> Laranja -> Amarelo)
            let r=0, g=0, b=0;
            if (val < 50) { r=0; g=0; b=val*2; } // Azul escuro
            else if (val < 150) { r=val; g=0; b=255-val; } // Roxo
            else { r=255; g=val; b=0; } // Amarelo/Quente

            let ptr = i * 4;
            imgData.data[ptr] = r;
            imgData.data[ptr+1] = g;
            imgData.data[ptr+2] = b;
            imgData.data[ptr+3] = 255;
        }
        ctxWater.putImageData(imgData, 0, 0);

        // 3. Gravação de Dados (5x por segundo aprox para não encher memória)
        if (state.recording && Math.random() > 0.8) {
            state.logs.push([
                new Date().toLocaleTimeString(),
                state.gps.lat,
                state.gps.lon,
                state.gps.acc,
                state.magCurrent.toFixed(2),
                (state.magCurrent - state.magBase).toFixed(2),
                state.freqPeak,
                state.vlfLevel
            ]);
            els.rec.innerText = `GRAVANDO (${state.logs.length})`;
        }
    }
</script>
</body>
</html>