<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Visualizador de Mapas Pro - Otimizado</title>
    <style>
        /* --- ESTILOS GERAIS --- */
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: Arial, sans-serif; position: relative; }
        #map { height: 100%; width: 100%; }
        
        /* MENUS E INTERFACE */
        .menu { position: absolute; top: 50%; left: 20px; transform: translateY(-50%); background-color: white; border-radius: 8px; box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2); z-index: 1000; display: flex; flex-direction: column; align-items: center; padding: 10px 0; max-height: 70vh; overflow-y: auto; scrollbar-width: none; -ms-overflow-style: none; transition: transform 0.3s ease, opacity 0.3s ease; }
        .menu::-webkit-scrollbar { display: none; }
        .menu.hidden { transform: translate(-200%, -50%); opacity: 0; pointer-events: none; }
        
        .menu button { position: relative; background-color: #ffffff; border: none; padding: 10px; margin: 5px 0; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2); cursor: pointer; transition: all 0.2s; flex-shrink: 0; }
        .menu button:hover { background-color: #f0f0f0; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); }
        .menu button img { width: 22px; height: 22px; }
        .menu button#btnRoutePlanner.active, .menu button#btnTrailMenu.active { background-color: #d1e3ff; box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3); }
        
        .button-legend { position: absolute; top: 50%; left: 50px; transform: translateY(-50%); background: rgba(255,255,255,0.9); border-radius: 4px; box-shadow: 0 2px 6px rgba(0,0,0,0.2); padding: 5px; font-size: 12px; white-space: nowrap; z-index: 2000; display: none; }
        
        /* BARRA DE BUSCA */
        .search-bar { position: absolute; top: 20px; left: 20px; width: 300px; background-color: white; border-radius: 8px; box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2); z-index: 1000; display: flex; padding: 10px; align-items: center; gap: 10px; }
        .search-bar input { flex: 1; border: none; outline: none; padding: 10px; font-size: 14px; border-radius: 8px; background-color: #f9f9f9; box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1); }
        .search-bar button { background-color: #4285F4; color: white; border: none; padding: 10px; border-radius: 8px; cursor: pointer; transition: background-color 0.3s; }
        .search-bar button:hover { background-color: #357ae8; }
        
        /* BOT√ÉO TOGGLE UI */
        .toggle-menu-btn { position: absolute; top: 20px; left: 340px; width: 40px; height: 40px; background-color: white; border-radius: 8px; box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2); z-index: 1000; display: flex; align-items: center; justify-content: center; border: none; cursor: pointer; transition: background-color 0.3s; }
        .toggle-menu-btn:hover { background-color: #f0f0f0; }
        .toggle-menu-btn img { width: 20px; height: 20px; }

        /* RESULTADOS DA BUSCA */
        .search-results { position: absolute; top: 70px; left: 20px; width: 320px; max-height: 250px; overflow-y: auto; background-color: white; border-radius: 8px; box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2); z-index: 1000; display: none; }
        .search-results ul { list-style: none; margin: 0; padding: 0; }
        .search-results li { padding: 10px; border-bottom: 1px solid #f0f0f0; display: flex; justify-content: space-between; align-items: center; }
        .search-results li:hover { background-color: #f0f0f0; }
        .search-results .result-info { flex-grow: 1; cursor: default; }
        .search-results .result-info small { color: #555; font-size: 0.8em; }
        .search-results .result-actions { display: flex; gap: 5px; flex-shrink: 0; margin-left: 10px; }
        .search-results button { background-color: #4285F4; color: white; border: none; padding: 5px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; }

        /* MENUS FLUTUANTES */
        .maps-menu, .line-menu, .loaded-files-menu, .style-menu, .marker-group-menu, .storage-menu, .tools-menu, .trail-menu {
            position: absolute; top: 80px; left: 70px; background: #fff; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.2); z-index: 2000; padding: 10px; display: none; max-height: 400px; overflow-y: auto;
        }
        .maps-menu, .line-menu { width: 300px; }
        .loaded-files-menu { width: 220px; }
        .style-menu { width: 200px; }
        .marker-group-menu { width: 240px; }
        
        .trail-menu { width: 280px; max-height: 65vh; flex-direction: column; gap: 10px; padding: 15px; }
        .tools-menu { width: 280px; flex-direction: column; gap: 15px; padding: 15px; }
        .tools-menu h3, .trail-menu h3, .maps-menu h3 { margin: 0 0 10px 0; font-size: 16px; text-align: center; border-bottom: 1px solid #eee; padding-bottom: 5px; }
        .tool-item { display: flex; flex-direction: column; gap: 5px; margin-bottom: 10px; }
        .tool-item label { font-size: 13px; font-weight: bold; color: #333; display: flex; justify-content: space-between; align-items: center; }
        .tool-item input[type="range"], .tool-item select, .tool-item input[type="color"] { width: 100%; cursor: pointer; }

        .maps-menu ul, .line-menu ul, .loaded-files-menu ul, .style-menu ul, .marker-group-menu ul, .trail-list { list-style: none; margin: 0; padding: 0; }
        .maps-menu li, .line-menu li, .style-menu li, .marker-group-menu li { padding: 8px 10px; cursor: pointer; border-bottom: 1px solid #f0f0f0; }
        .maps-menu li:hover, .style-menu li:hover { background-color: #f0f0f0; }
        
        .maps-menu .batch-actions { display: flex; align-items: center; justify-content: space-between; padding: 5px 0; margin-bottom: 5px; border-bottom: 1px solid #eee; font-size: 12px; }
        .maps-menu .batch-actions button { background-color: #4285F4; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; }
        .maps-menu li { display: flex; align-items: center; gap: 8px; }
        .maps-menu li input[type="checkbox"] { cursor: pointer; }
        .maps-menu li span.file-name { flex-grow: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

        .maps-menu .map-status { font-size: 10px; padding: 2px 5px; border-radius: 4px; margin-left: 5px; white-space: nowrap; }
        .status-saved { background-color: #e6fffa; color: #047857; border: 1px solid #a7f3d0; }
        .status-cloud { background-color: #f3f4f6; color: #6b7280; border: 1px solid #e5e7eb; }
        
        .loaded-files-menu li { display: flex; justify-content: space-between; align-items: center; padding: 5px 0; border-bottom: 1px solid #f0f0f0; }
        .loaded-files-menu li button { background-color: #e74c3c; color: white; border: none; padding: 3px 6px; border-radius: 4px; cursor: pointer; font-size: 10px; }

        .trail-list li { padding: 8px 0; border-bottom: 1px solid #eee; display: flex; flex-direction: column; gap: 5px; }
        .trail-item-header { display: flex; justify-content: space-between; align-items: center; font-weight: bold; font-size: 12px; }
        .trail-item-actions { display: flex; gap: 5px; justify-content: flex-end; }
        .trail-item-actions button { background: #eee; border: 1px solid #ccc; border-radius: 4px; padding: 4px 8px; font-size: 11px; cursor: pointer; }
        .trail-item-actions button:hover { background: #ddd; }
        .btn-kml { background-color: #e8f5e9 !important; color: #2e7d32; border-color: #a5d6a7 !important; }
        .btn-whatsapp { background-color: #25D366 !important; color: #fff; border-color: #128C7E !important; font-weight: bold; }
        .btn-del { background-color: #ffebee !important; color: #c62828; border-color: #ef9a9a !important; }
        .btn-view { background-color: #e3f2fd !important; color: #1565c0; border-color: #90caf9 !important; }

        .switch { position: relative; display: inline-block; width: 50px; height: 24px; flex-shrink: 0; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; }
        input:checked + .slider { background-color: #4285F4; }
        input:checked + .slider:before { transform: translateX(26px); }
        .slider.round { border-radius: 24px; }
        .slider.round:before { border-radius: 50%; }

        .progress-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 9999; display: flex; justify-content: center; align-items: center; color: white; }
        .progress-content { background: #333; padding: 30px; border-radius: 10px; text-align: center; width: 400px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        .progress-bar-container { width: 100%; background-color: #555; border-radius: 5px; margin: 15px 0; }
        .progress-bar { width: 0%; height: 20px; background-color: #4285F4; border-radius: 5px; transition: width 0.2s linear; }

        .route-panel { position: absolute; top: 20px; right: 20px; background: #fff; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.2); z-index: 2000; padding: 15px; width: 280px; max-height: 400px; display: none; flex-direction: column; }
        .route-panel h3 { margin: 0 0 10px 0; font-size: 16px; text-align: center; }
        .route-panel p { font-size: 12px; color: #555; margin: 0 0 10px 0; border-bottom: 1px solid #f0f0f0; padding-bottom: 10px; }
        .route-panel ul { list-style: decimal; margin: 0 0 10px 20px; padding: 0; max-height: 200px; overflow-y: auto; font-size: 13px; flex-grow: 1; }
        .route-panel li { display: flex; justify-content: space-between; align-items: center; padding: 4px 0; }
        .route-panel li span { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; padding-right: 10px; }
        .route-panel li .remove-wp { background-color: #e74c3c; color: white; border: none; padding: 2px 5px; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: bold; margin-left: 10px; flex-shrink: 0; }
        .route-panel-footer { margin-top: 10px; border-top: 1px solid #f0f0f0; padding-top: 10px; }
        .route-panel-buttons { display: flex; justify-content: space-between; margin-top: 10px; }
        .route-panel button { background-color: #ccc; color: #333; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-size: 13px; flex-basis: 48%; }
        .route-panel button#btnGenerateRoute { background-color: #4285F4; color: white; font-weight: bold; }

        .storage-menu { width: 300px; display: none; flex-direction: column; gap: 10px; }
        .storage-menu h3 { margin: 0 0 5px 0; font-size: 16px; text-align: center; }
        .storage-menu p { font-size: 12px; color: #555; text-align: center; margin: 0 0 10px 0; border-bottom: 1px solid #f0f0f0; padding-bottom: 10px; }
        .storage-menu .storage-buttons { display: flex; flex-direction: column; gap: 10px; }
        .storage-menu .storage-buttons button { border: none; padding: 12px; border-radius: 5px; cursor: pointer; font-size: 13px; font-weight: bold; text-align: left; display: flex; flex-direction: column; transition: background-color 0.2s; }
        .storage-menu .storage-buttons button small { font-size: 11px; font-weight: normal; opacity: 0.9; margin-top: 4px; }
        .storage-menu .btn-danger { background-color: #fbebee; color: #c0392b; border: 1px solid #e74c3c; }
        .storage-menu .btn-danger:hover { background-color: #fadbd8; }
        .storage-menu .btn-warning { background-color: #fef9e7; color: #b08f00; border: 1px solid #f1c40f; }
        .storage-menu .btn-warning:hover { background-color: #fcf3cf; }
        .storage-menu .btn-danger-full { background-color: #e74c3c; color: white; text-align: center; }
        .storage-menu .btn-danger-full:hover { background-color: #c0392b; }

        .maplibregl-popup-content { padding: 10px; font-size: 13px; }
        .maplibregl-popup-close-button { padding: 4px; }
        .marker-group-menu .color-box { width: 15px; height: 15px; margin-right: 10px; border: 1px solid #ccc; }
        .line-menu li label, .marker-group-menu li label { cursor: pointer; width: 100%; display: flex; align-items: center; }

        footer { position: absolute; bottom: 5px; width: 100%; text-align: center; font-size: 10px; color: #555; z-index: 1001; }
    </style>
    <link href="https://unpkg.com/maplibre-gl/dist/maplibre-gl.css" rel="stylesheet" />
    
    <script src="https://unpkg.com/maplibre-gl/dist/maplibre-gl.js"></script>
    <script src="https://unpkg.com/@tmcw/togeojson"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-G7MC2S78V6"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-G7MC2S78V6');
    </script>
</head>
<body>
    <div id="map"></div>

    <div id="progressOverlay" class="progress-overlay" style="display: none;">
        <div class="progress-content">
            <h3>Salvando no Banco de Dados...</h3>
            <p>Os arquivos est√£o sendo processados.</p>
            <div class="progress-bar-container">
                <div id="progressBar" class="progress-bar"></div>
            </div>
            <p id="progressText">0 / 0</p>
        </div>
    </div>

    <div class="search-bar">
        <input type="text" id="searchInput" placeholder="Buscar no mapa..." />
        <button id="btnSearch">Buscar</button>
    </div>

    <button id="btnToggleUI" class="toggle-menu-btn" title="Ocultar/Exibir Menu Lateral">
        <img src="√≠cones/eye.svg" alt="Ver/Ocultar">
    </button>

    <div class="menu" id="mainMenu">
        <button id="btnMaps" aria-label="Gerenciar Mapas">
            <img src="√≠cones/map.svg" alt="Mapas">
            <div class="button-legend">Gerenciar Mapas</div>
        </button>

        <button id="btnMarkerGroups" aria-label="Filtrar por grupos de postos">
            <img src="√≠cones/utility-pole.svg" alt="Grupos de Postos">
            <div class="button-legend">Grupos de Postos</div>
        </button>
        <button id="btnLineGroups" aria-label="Filtrar por grupos de linhas">
            <img src="√≠cones/waypoints.svg" alt="Grupos de Linhas">
            <div class="button-legend">Grupos de Linhas</div>
        </button>
        <button id="btnNames" aria-label="Exibir ou ocultar os nomes dos marcadores">
            <img src="√≠cones/text-align-start.svg" alt="Exibir/Ocultar Nomes">
            <div class="button-legend">Exibir/Ocultar Nomes</div>
        </button>

        <button id="btnTools" aria-label="Ferramentas de Visualiza√ß√£o">
            <img src="√≠cones/settings.svg" alt="Ferramentas"> <div class="button-legend">Ferramentas</div>
        </button>

        <button id="btnTrailMenu" aria-label="Rastro de Inspe√ß√£o">
            <img src="√≠cones/activity.svg" alt="Rastro"> 
            <div class="button-legend">Rastro de Inspe√ß√£o</div>
        </button>

        <button id="btnLocation" aria-label="Ir para minha localiza√ß√£o atual">
            <img src="√≠cones/navigation.svg" alt="Minha Localiza√ß√£o">
            <div class="button-legend">Minha Localiza√ß√£o</div>
        </button>
        <button id="btnReset" aria-label="Resetar a visualiza√ß√£o do mapa">
            <img src="√≠cones/rotate-cw.svg" alt="Resetar Vis√£o">
            <div class="button-legend">Resetar Vis√£o</div>
        </button>
        <button id="btnLoadedFiles" aria-label="Ver arquivos carregados atualmente">
            <img src="√≠cones/folder-open.svg" alt="Arquivos Carregados">
            <div class="button-legend">Arquivos Carregados</div>
        </button>
        <button id="btnStyles" aria-label="Mudar o estilo do mapa">
            <img src="√≠cones/palette.svg" alt="Estilos do Mapa">
            <div class="button-legend">Estilos do Mapa</div>
        </button>
        
        <button id="btnRoutePlanner" aria-label="Planejar Rota">
            <img src="√≠cones/route.svg" alt="Planejar Rota"> 
            <div class="button-legend">Planejar Rota</div>
        </button>

        <button id="btnStorageMenu" aria-label="Gerenciar Armazenamento">
            <img src="√≠cones/database-zap.svg" alt="Limpar Dados"> 
            <div class="button-legend">Limpar Dados</div>
        </button>

        <button id="btnSupport" aria-label="Grupo de Suporte">
            <img src="√≠cones/handshake.svg" alt="Suporte">
            <div class="button-legend">Suporte WhatsApp</div>
        </button>
    </div>

    <div id="searchResults" class="search-results"></div>

    <div class="maps-menu" id="mapsMenu">
        <h3>Gerenciar Mapas</h3>
        
        <div id="selectDevice" style="font-weight:bold; color:#4285F4; border-bottom:1px solid #eee; padding-bottom:8px; margin-bottom:8px; cursor:pointer; display:flex; align-items:center;">
            <img src="√≠cones/upload.svg" style="width:16px; margin-right:8px;" alt="Upload">
            <span>üìÇ Carregar do Dispositivo...</span>
        </div>

        <input type="text" id="mapListSearch" placeholder="Filtrar lista..." style="width: 93%; padding: 8px; margin-bottom: 5px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;">
        
        <div class="batch-actions">
            <label style="cursor:pointer; display:flex; align-items:center;">
                <input type="checkbox" id="chkSelectAllMaps" style="margin-right:5px;"> Todos
            </label>
            <button id="btnLoadSelectedMaps">Carregar Selecionados</button>
        </div>
        
        <div style="font-size:11px; color:#666; margin-bottom:10px; text-align:center;">
            Marque para carregar v√°rios ou clique no nome para carregar um.
        </div>
        
        <ul id="kmzList"></ul>
    </div>

    <div class="trail-menu" id="trailMenu" style="display: none;">
        <h3>Rastro de Inspe√ß√£o</h3>
        
        <div class="tool-item">
            <label>Cor da Linha:</label>
            <input type="color" id="trailColor" value="#d63384" style="height:30px; padding:0;">
        </div>

        <div class="tool-item">
            <label>Velocidade de Grava√ß√£o:</label>
            <select id="trailInterval">
                <option value="2000">Alta Precis√£o (2s)</option>
                <option value="5000" selected>Padr√£o (5s)</option>
                <option value="10000">Econ√¥mico (10s)</option>
                <option value="30000">Longo Percurso (30s)</option>
            </select>
        </div>

        <div class="tool-item" style="flex-direction: row; align-items: center; justify-content: space-between; border-top: 1px solid #eee; padding-top: 10px; margin-top: 5px;">
            <span>Gravar Rastro</span>
            <label class="switch">
                <input type="checkbox" id="chkUserTrail">
                <span class="slider round"></span>
            </label>
        </div>
        
        <div style="font-size: 11px; text-align: center; margin-top: 5px; color:#555;">
            Pontos atuais: <span id="trailPointCount">0</span>
        </div>

        <h3 style="margin-top: 15px; font-size: 14px;">Rastros Salvos</h3>
        <ul id="savedTrailsList" class="trail-list" style="max-height: 350px; overflow-y: auto;">
            <li style="text-align:center; color:#999; font-size:11px;">Nenhum rastro salvo.</li>
        </ul>
    </div>

    <div class="tools-menu" id="toolsMenu" style="display: none;">
        <h3>Ferramentas de Visualiza√ß√£o</h3>
        <div class="tool-item">
            <label>Espessura da Linha: <span id="valLineWidth">4</span>px</label>
            <input type="range" id="rngLineWidth" min="1" max="15" value="4">
        </div>
        <div class="tool-item">
            <label>Tamanho do Marcador: <span id="valMarkerSize">6</span>px</label>
            <input type="range" id="rngMarkerSize" min="2" max="20" value="6">
        </div>
        <div class="tool-item">
            <label>Tamanho do Texto: <span id="valTextSize">12</span>px</label>
            <input type="range" id="rngTextSize" min="8" max="24" value="12">
        </div>
        <div class="tool-item">
            <label>Qtd. Marcadores: <span id="valMarkerLimit">500</span></label>
            <input type="range" id="rngMarkerLimit" min="0" max="3000" value="500" step="50">
        </div>
    </div>

    <div class="line-menu" id="lineMenu">
        <input type="text" id="lineGroupSearch" placeholder="Buscar alimentador..." style="width: 93%; padding: 8px; margin-bottom: 10px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; display: block;">
        <div class="visibility-toggle">
            <label>
                <input type="checkbox" id="toggleAllLinesVisibility"> Exibir Todas as Linhas
            </label>
        </div>
        <div style="display:flex; gap:10px; margin-bottom:10px;">
            <button id="hideAll">Ocultar Todas</button>
            <button id="showAll">Exibir Todas</button>
        </div>
        <ul id="lineGroupsList"></ul>
    </div>
    <div class="loaded-files-menu" id="loadedFilesMenu">
        <h3>Arquivos Carregados</h3>
        <ul id="loadedFilesList"></ul>
    </div>

    <div class="style-menu" id="styleMenu">
        <ul id="styleList"></ul>
    </div>
    
    <div class="marker-group-menu" id="markerGroupMenu">
        <h3>Grupos de Postos</h3>
         <div class="visibility-toggle">
            <label>
                <input type="checkbox" id="toggleAllMarkersVisibility"> Exibir Todos os Marcadores
            </label>
         </div>
        <div style="display:flex; gap:10px; margin-bottom:10px;">
            <button id="hideAllMarkerGroups">Ocultar Todos</button>
            <button id="showAllMarkerGroups">Exibir Todos</button>
        </div>
        <ul id="markerGroupsList"></ul>
    </div>
    
    <div class="route-panel" id="routePanel">
        <h3>Planejador de Rota</h3>
        <p>A rota usar√° seu GPS como origem. Selecione as paradas (M√°x: 10). O √∫ltimo ponto ser√° o destino.</p>
        <ul id="routeList"></ul>
        <div class="route-panel-footer">
            <span id="routeCounter">Pontos: 0 / 10</span>
            <div class="route-panel-buttons">
                <button id="btnCancelRoute">Limpar</button>
                <button id="btnGenerateRoute">Gerar Rota</button>
            </div>
        </div>
    </div>

    <div class="storage-menu" id="storageMenu">
        <h3>Gerenciar Armazenamento</h3>
        <p>Use com cuidado. Isso remover√° dados salvos no seu navegador para este site.</p>
        <div class="storage-buttons">
            <button id="btnDeleteAllTrails" class="btn-warning">
                Apagar Todos os Rastros Salvos
                <small>Limpa a lista de hist√≥rico de inspe√ß√£o.</small>
            </button>

            <button id="btnResetOfflineDB" class="btn-danger">
                Limpar Banco de Mapas
                <small>Remove todos os mapas KMZ salvos.</small>
            </button>
            <button id="btnResetLocalStorage" class="btn-warning">
                Limpar Configura√ß√µes
                <small>Reseta cores, arquivos recentes (servidor e dispositivo) e modo.</small>
            </button>
            <button id="btnResetAllStorage" class="btn-danger-full">
                Resetar Tudo
                <small>Limpa cache, configura√ß√µes e recarrega.</small>
            </button>
        </div>
    </div>
    <footer>
    Todos direitos reservados a Lucas Teixeira ‚Ä¢ Atualizado em 25/11/2025
    </footer>
    <script>
        const DB_NAME = 'KMZOfflineDB';
        const DB_VERSION = 4; 
        const GEOJSON_STORE_NAME = 'geojson_files';
        const SPATIAL_INDEX_STORE_NAME = 'spatial_index';
        const TRAIL_STORE_NAME = 'user_trails'; 
        const MAX_WAYPOINTS = 10;
        
        const BATCH_SIZE = 2000;

        let routeWaypoints = [];
        let routeMarkers = [];
        
        let currentTrailCoordinates = [];
        let trailWatchId = null;
        let lastTrailUpdateTime = 0;

        const state = {
            isRoutePlanning: false, 
            markersVisible: true,
            namesVisible: true,
            linesVisible: true,
            userLocation: null,
            files: [],
            selectedGroups: new Map(),
            markerGroups: {
                '-FU': { color: 'red', visible: true },
                '-FA': { color: '#FFA500', visible: true },
                '-RE': { color: 'green', visible: true },
                'TR': { color: 'blue', visible: true },  
                'default': { color: '#FF5722', visible: true }
            },
            visualSettings: {
                lineWidth: 4, markerSize: 6, textSize: 12, markerLimit: 500 
            }
        };
        
        function loadSavedMarkerColors() {
            const saved = localStorage.getItem('markerGroupColors');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    Object.keys(parsed).forEach(key => {
                        if (state.markerGroups[key]) {
                            state.markerGroups[key].color = parsed[key];
                        }
                    });
                } catch (e) { console.error("Erro ao carregar cores dos marcadores:", e); }
            }
        }
        loadSavedMarkerColors();

        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = event => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(GEOJSON_STORE_NAME)) {
                        db.createObjectStore(GEOJSON_STORE_NAME, { keyPath: 'name' });
                    }
                    if (!db.objectStoreNames.contains(SPATIAL_INDEX_STORE_NAME)) {
                        db.createObjectStore(SPATIAL_INDEX_STORE_NAME, { keyPath: 'name' });
                    }
                    if (!db.objectStoreNames.contains(TRAIL_STORE_NAME)) {
                        db.createObjectStore(TRAIL_STORE_NAME, { keyPath: 'id' });
                    }
                };
                request.onsuccess = event => resolve(event.target.result);
                request.onerror = event => reject(event.target.error);
            });
        }

        async function saveDataToDB(storeName, data) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(data);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        async function getDataFromDB(storeName, key) {
             const db = await openDB();
                 return new Promise((resolve, reject) => {
                     const transaction = db.transaction([storeName], 'readonly');
                     const store = transaction.objectStore(storeName);
                     const request = key ? store.get(key) : store.getAll();
                     request.onsuccess = () => resolve(request.result);
                     request.onerror = () => reject(request.error);
                 });
             }
        
        async function deleteDataFromDB(storeName, key) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(key);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
        
        async function clearStore(storeName) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.clear();
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        async function updateSavedTrailsList() {
            const listEl = document.getElementById('savedTrailsList');
            listEl.innerHTML = '';
            try {
                const trails = await getDataFromDB(TRAIL_STORE_NAME);
                if (!trails || trails.length === 0) {
                    listEl.innerHTML = '<li style="text-align:center; color:#999; font-size:11px;">Nenhum rastro salvo.</li>';
                    return;
                }
                
                trails.sort((a, b) => b.id - a.id);

                trails.forEach(trail => {
                    const li = document.createElement('li');
                    
                    const header = document.createElement('div');
                    header.className = 'trail-item-header';
                    const date = new Date(trail.id).toLocaleDateString('pt-BR');
                    const time = new Date(trail.id).toLocaleTimeString('pt-BR', {hour: '2-digit', minute:'2-digit'});
                    header.innerHTML = `<span>${trail.name || 'Rastro'} (${date} ${time})</span>`;
                    
                    const actions = document.createElement('div');
                    actions.className = 'trail-item-actions';
                    
                    const btnView = document.createElement('button');
                    btnView.textContent = 'Ver';
                    btnView.className = 'btn-view';
                    btnView.onclick = () => {
                        const source = map.getSource('user-trail');
                        if(source) {
                            source.setData({
                                type: 'Feature',
                                geometry: { type: 'LineString', coordinates: trail.coordinates }
                            });
                            if(trail.color) {
                                map.setPaintProperty('user-trail-layer', 'line-color', trail.color);
                                document.getElementById('trailColor').value = trail.color;
                            }
                            const bounds = new maplibregl.LngLatBounds();
                            trail.coordinates.forEach(coord => bounds.extend(coord));
                            map.fitBounds(bounds, { padding: 50 });
                        }
                    };

                    const btnKml = document.createElement('button');
                    btnKml.textContent = 'KML';
                    btnKml.className = 'btn-kml';
                    btnKml.onclick = () => exportTrailToKML(trail);

                    const btnZap = document.createElement('button');
                    btnZap.innerHTML = '<img src="√≠cones/share-2.svg" style="width:12px; height:12px; filter: brightness(0) invert(1);">';
                    btnZap.className = 'btn-whatsapp';
                    btnZap.onclick = () => shareTrailOnWhatsApp(trail);

                    const btnDel = document.createElement('button');
                    btnDel.textContent = 'X';
                    btnDel.className = 'btn-del';
                    btnDel.onclick = async () => {
                        if(confirm('Apagar este rastro?')) {
                            await deleteDataFromDB(TRAIL_STORE_NAME, trail.id);
                            updateSavedTrailsList();
                        }
                    };

                    actions.appendChild(btnView);
                    actions.appendChild(btnKml);
                    actions.appendChild(btnZap);
                    actions.appendChild(btnDel);
                    
                    li.appendChild(header);
                    li.appendChild(actions);
                    listEl.appendChild(li);
                });
            } catch(e) { console.error("Erro ao listar rastros", e); }
        }

        function createKMLBlob(trail) {
            const coordsString = trail.coordinates.map(c => `${c[0]},${c[1]},0`).join(' ');
            const kmlContent = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>${trail.name}</name>
    <Style id="trailStyle">
      <LineStyle>
        <color>ff${trail.color.replace('#','')}00</color>
        <width>4</width>
      </LineStyle>
    </Style>
    <Placemark>
      <name>${trail.name}</name>
      <styleUrl>#trailStyle</styleUrl>
      <LineString>
        <tessellate>1</tessellate>
        <coordinates>${coordsString}</coordinates>
      </LineString>
    </Placemark>
  </Document>
</kml>`;
            return new Blob([kmlContent], { type: 'application/vnd.google-earth.kml+xml' });
        }

        function exportTrailToKML(trail) {
            const blob = createKMLBlob(trail);
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `Rastro_${new Date(trail.id).toISOString().slice(0,10)}.kml`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        async function shareTrailOnWhatsApp(trail) {
            const blob = createKMLBlob(trail);
            const file = new File([blob], `Rastro_${trail.name}.kml`, { type: 'application/vnd.google-earth.kml+xml' });

            if (navigator.canShare && navigator.canShare({ files: [file] })) {
                try {
                    await navigator.share({
                        files: [file],
                        title: 'Rastro de Inspe√ß√£o',
                        text: `Segue o arquivo KML do rastro: ${trail.name}`
                    });
                } catch (error) {
                    console.log('Erro ao compartilhar ou cancelado:', error);
                }
            } else {
                const startCoord = trail.coordinates[0];
                const date = new Date(trail.id).toLocaleDateString('pt-BR');
                const text = `*Rastro de Inspe√ß√£o*\nNome: ${trail.name}\nData: ${date}\nIn√≠cio: https://www.google.com/maps/dir/?api=1&destination=${startCoord[1]},${startCoord[0]}`;
                const url = `https://api.whatsapp.com/send?text=${encodeURIComponent(text)}`;
                window.open(url, '_blank');
                alert("No computador, o WhatsApp Web n√£o permite anexar arquivos automaticamente. O link com a localiza√ß√£o inicial foi aberto.");
            }
        }

        let spatialIndex = [];
        let allPointFeatures = [];
        let dynamicMarkerSource = null;
        let updateMarkersTimeout;

        const esriSatelliteCleanStyle = {
            'version': 8,
            'sources': {
                'esri-satellite': {
                    'type': 'raster',
                    'tiles': ['https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'],
                    'tileSize': 256,
                    'attribution': '¬© Esri, Maxar, Earthstar Geographics',
                    'maxzoom': 19
                }
            },
            'layers': [
                { 'id': 'esri-satellite-layer', 'type': 'raster', 'source': 'esri-satellite', 'minzoom': 0, 'maxzoom': 24 }
            ],
            'glyphs': 'https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf'
        };

        const esriSatelliteHybridStyle = {
            'version': 8,
            'sources': {
                'esri-satellite': {
                    'type': 'raster',
                    'tiles': ['https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'],
                    'tileSize': 256,
                    'attribution': '¬© Esri, Maxar, Earthstar Geographics',
                    'maxzoom': 19
                },
                'esri-transportation': {
                    'type': 'raster',
                    'tiles': ['https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Transportation/MapServer/tile/{z}/{y}/{x}'],
                    'tileSize': 256,
                    'maxzoom': 19
                },
                'esri-labels': {
                    'type': 'raster',
                    'tiles': ['https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}'],
                    'tileSize': 256,
                    'maxzoom': 19
                }
            },
            'layers': [
                { 'id': 'esri-satellite-layer', 'type': 'raster', 'source': 'esri-satellite', 'minzoom': 0, 'maxzoom': 24 },
                { 'id': 'esri-transportation-layer', 'type': 'raster', 'source': 'esri-transportation', 'minzoom': 0, 'maxzoom': 24 },
                { 'id': 'esri-labels-layer', 'type': 'raster', 'source': 'esri-labels', 'minzoom': 0, 'maxzoom': 24 }
            ],
            'glyphs': 'https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf'
        };

        const mapStyles = [
            { name: 'Positron', url: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json' },
            { name: 'Dark Matter', url: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json' },
            { name: 'Voyager', url: 'https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json' },
            { name: 'Esri Sat√©lite (Limpo)', style: esriSatelliteCleanStyle },
            { name: 'Esri Sat√©lite (Com Nomes)', style: esriSatelliteHybridStyle }
        ];

        const colorPalette = ['#FF6347', '#4682B4', '#B0E0E6', '#FFD700', '#5F9EA0', '#F0E68C', '#F08080', '#20B2AA', '#ADD8E6', '#FFA07A', '#87CEEB', '#E6E6FA', '#FF7F50', '#6A5ACD', '#FFFACD', '#E55300', '#483D8B', '#DDA0DD', '#D4A29C', '#008080', '#87CEFA', '#C46210', '#53736F', '#98FB98', '#F4A460', '#3B83BD', '#FFB6C1', '#FF4500', '#33A1C9', '#F5DEB3'];
        
        let groupColorMap; 
        
        function loadGroupColorMap() {
            const storedMap = localStorage.getItem('groupColorMap');
            if (storedMap) {
                try {
                    const obj = JSON.parse(storedMap);
                    groupColorMap = new Map(Object.entries(obj));
                } catch (e) { groupColorMap = new Map(); }
            } else { groupColorMap = new Map(); }
        }

        function saveGroupColorMap() {
            try {
                const obj = Object.fromEntries(groupColorMap);
                localStorage.setItem('groupColorMap', JSON.stringify(obj));
            } catch (e) { console.error("Erro ao salvar mapa de cores:", e); }
        }
        
        loadGroupColorMap(); 

        const map = new maplibregl.Map({
            container: 'map',
            style: 'https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json',
            center: [-47.068847, -22.934973],
            zoom: 8,
            maxZoom: 24 
        });

        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        
        const btnMaps = document.getElementById('btnMaps');
        const mapsMenu = document.getElementById('mapsMenu');
        const kmzList = document.getElementById('kmzList');
        
        const lineMenu = document.getElementById('lineMenu');
        const lineGroupsList = document.getElementById('lineGroupsList');
        const loadedFilesMenu = document.getElementById('loadedFilesMenu');
        const loadedFilesList = document.getElementById('loadedFilesList');
        const btnLoadedFiles = document.getElementById('btnLoadedFiles');
        const styleMenu = document.getElementById('styleMenu');
        const markerGroupMenu = document.getElementById('markerGroupMenu');
        const markerGroupsList = document.getElementById('markerGroupsList');
        
        const btnTools = document.getElementById('btnTools');
        const toolsMenu = document.getElementById('toolsMenu');
        
        const btnTrailMenu = document.getElementById('btnTrailMenu');
        const trailMenu = document.getElementById('trailMenu');
        const chkUserTrail = document.getElementById('chkUserTrail');
        const trailPointCount = document.getElementById('trailPointCount');
        const btnDeleteAllTrails = document.getElementById('btnDeleteAllTrails');
        const trailColorInput = document.getElementById('trailColor');
        const trailIntervalSelect = document.getElementById('trailInterval');

        const rngLineWidth = document.getElementById('rngLineWidth');
        const valLineWidth = document.getElementById('valLineWidth');
        const rngMarkerSize = document.getElementById('rngMarkerSize');
        const valMarkerSize = document.getElementById('valMarkerSize');
        const rngTextSize = document.getElementById('rngTextSize');
        const valTextSize = document.getElementById('valTextSize');
        const rngMarkerLimit = document.getElementById('rngMarkerLimit');
        const valMarkerLimit = document.getElementById('valMarkerLimit');

        const btnRoutePlanner = document.getElementById('btnRoutePlanner');
        const routePanel = document.getElementById('routePanel');
        const routeList = document.getElementById('routeList');
        const routeCounter = document.getElementById('routeCounter');
        const btnGenerateRoute = document.getElementById('btnGenerateRoute');
        const btnCancelRoute = document.getElementById('btnCancelRoute');
        
        const storageMenu = document.getElementById('storageMenu');
        const btnResetOfflineDB = document.getElementById('btnResetOfflineDB');
        const btnResetLocalStorage = document.getElementById('btnResetLocalStorage');
        const btnResetAllStorage = document.getElementById('btnResetAllStorage');

        const progressOverlay = document.getElementById('progressOverlay');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');

        const btnToggleUI = document.getElementById('btnToggleUI');
        const mainMenu = document.getElementById('mainMenu');

        const toggleAllMarkersVisibilityCheckbox = document.getElementById('toggleAllMarkersVisibility');
        const toggleAllLinesVisibilityCheckbox = document.getElementById('toggleAllLinesVisibility');
        
        const chkSelectAllMaps = document.getElementById('chkSelectAllMaps');
        const btnLoadSelectedMaps = document.getElementById('btnLoadSelectedMaps');

        const predefinedFiles = [
             { name: 'AGUAS DE LINDOIA.kmz', url: './AGUAS DE LINDOIA.kmz' },
             { name: 'AGUDOS.kmz', url: './AGUDOS.kmz' },
             { name: 'ALTINOPOLIS.kmz', url: './ALTINOPOLIS.kmz' },
             { name: 'AMERICANA.kmz', url: './AMERICANA.kmz' },
             { name: 'AMPARO.kmz', url: './AMPARO.kmz' },
             { name: 'ARACATUBA.kmz', url: './ARACATUBA.kmz' },
             { name: 'ARARAQUARA.kmz', url: './ARARAQUARA.kmz' },
             { name: 'BARIRI.kmz', url: './BARIRI.kmz' },
             { name: 'BARRA BONITA.kmz', url: './BARRA BONITA.kmz' },
             { name: 'BARRETOS.kmz', url: './BARRETOS.kmz' },
             { name: 'BATATAIS.kmz', url: './BATATAIS.kmz' },
             { name: 'BAURU.kmz', url: './BAURU.kmz' },
             { name: 'BEBEDOURO.kmz', url: './BEBEDOURO.kmz' },
             { name: 'BIRIGUI.kmz', url: './BIRIGUI.kmz' },
             { name: 'BOA ESPERANCA DO SUL.kmz', url: './BOA ESPERANCA DO SUL.kmz' },
             { name: 'BOTUCATU.kmz', url: './BOTUCATU.kmz' },
             { name: 'BRAUNA.kmz', url: './BRAUNA.kmz' },
             { name: 'BROTAS.kmz', url: './BROTAS.kmz' },
             { name: 'CAFELANDIA.kmz', url: './CAFELANDIA.kmz' },
             { name: 'CAJOBI.kmz', url: './CAJOBI.kmz' },
             { name: 'CAJURU.kmz', url: './CAJURU.kmz' },
             { name: 'CAMPINAS BARAO GERALDO-1.kmz', url: './CAMPINAS BARAO GERALDO-1.kmz' },
             { name: 'CAMPINAS CAMPO GRANDE-1.kmz', url: './CAMPINAS CAMPO GRANDE-1.kmz' },
             { name: 'CAMPINAS CENTRO-1.kmz', url: './CAMPINAS CENTRO-1.kmz' },
             { name: 'CAMPINAS SOUZAS-1.kmz', url: './CAMPINAS SOUZAS-1.kmz' },
             { name: 'CAMPINAS TREVO-1.kmz', url: './CAMPINAS TREVO-1.kmz' },
             { name: 'CAPIVARI.kmz', url: './CAPIVARI.kmz' },
             { name: 'CONGONHAS.kmz', url: './CONGONHAS.kmz' },
             { name: 'COSMOPOLIS.kmz', url: './COSMOPOLIS.kmz' },
             { name: 'CRAVINHOS.kmz', url: './CRAVINHOS.kmz' },
             { name: 'DESCALVADO.kmz', url: './DESCALVADO.kmz' },
             { name: 'DOIS CORREGOS.kmz', url: './DOIS CORREGOS.kmz' },
             { name: 'DOURADO.kmz', url: './DOURADO.kmz' },
             { name: 'DUARTINA.kmz', url: './DUARTINA.kmz' },
             { name: 'ESPIRITO SANTO DO PINHAL.kmz', url: './ESPIRITO SANTO DO PINHAL.kmz' },
             { name: 'FRANCA.kmz', url: './FRANCA.kmz' },
             { name: 'GARCA.kmz', url: './GARCA.kmz' },
             { name: 'GAVIAO PEIXOTO.kmz', url: './GAVIAO PEIXOTO.kmz' },
             { name: 'GETULINA.kmz', url: './GETULINA.kmz' },
             { name: 'GUAIRA.kmz', url: './GUAIRA.kmz' },
             { name: 'GUANABARA.kmz', url: './GUANABARA.kmz' },
             { name: 'GUARARAPES.kmz', url: './GUARARAPES.kmz' },
             { name: 'GUARIBA.kmz', url: './GUARIBA.kmz' },
             { name: 'HIPODROMO.kmz', url: './HIPODROMO.kmz' },
             { name: 'HORTOLANDIA.kmz', url: './HORTOLANDIA.kmz' },
             { name: 'IACANGA.kmz', url: './IACANGA.kmz' },
             { name: 'IBIRA.kmz', url: './IBIRA.kmz' },
             { name: 'IBITINGA.kmz', url: './IBITINGA.kmz' },
             { name: 'IGARAPAVA.kmz', url: './IGARAPAVA.kmz' },
             { name: 'IPUA.kmz', url: './IPUA.kmz' },
             { name: 'ITAPIRA.kmz', url: './ITAPIRA.kmz' },
             { name: 'ITAPOLIS.kmz', url: './ITAPOLIS.kmz' },
             { name: 'ITATIBA.kmz', url: './ITATIBA.kmz' },
             { name: 'ITATINGA.kmz', url: './ITATINGA.kmz' },
             { name: 'ITUVERAVA.kmz', url: './ITUVERAVA.kmz' },
             { name: 'JABOTICABAL.kmz', url: './JABOTICABAL.kmz' },
             { name: 'JARDINOPOLIS.kmz', url: './JARDINOPOLIS.kmz' },
             { name: 'JAU.kmz', url: './JAU.kmz' },
             { name: 'JOSE BONIFACIO.kmz', url: './JOSE BONIFACIO.kmz' },
             { name: 'LENCOIS PAULISTA.kmz', url: './LENCOIS PAULISTA.kmz' },
             { name: 'LINS.kmz', url: './LINS.kmz' },
             { name: 'MARILIA.kmz', url: './MARILIA.kmz' },
             { name: 'MATAO.kmz', url: './MATAO.kmz' },
             { name: 'METROPOLITANA.kmz', url: './METROPOLITANA.kmz' },
             { name: 'MIGUELOPOLIS.kmz', url: './MIGUELOPOLIS.kmz' },
             { name: 'MIRASSOL.kmz', url: './MIRASSOL.kmz' },
             { name: 'MONTE ALTO.kmz', url: './MONTE ALTO.kmz' },
             { name: 'MONTE APRAZIVEL.kmz', url: './MONTE APRAZIVEL.kmz' },
             { name: 'MONTE MOR.kmz', url: './MONTE MOR.kmz' },
             { name: 'MORRO AGUDO.kmz', url: './MORRO AGUDO.kmz' },
             { name: 'MORRO DO CIPO.kmz', url: './MORRO DO CIPO.kmz' },
             { name: 'NOVA GRANADA.kmz', url: './NOVA GRANADA.kmz' },
             { name: 'OCAUCU.kmz', url: './OCAUCU.kmz' },
             { name: 'OLIMPIA.kmz', url: './OLIMPIA.kmz' },
             { name: 'ORLANDIA.kmz', url: './ORLANDIA.kmz' },
             { name: 'PARAISO.kmz', url: './PARAISO.kmz' },
             { name: 'PARDINHO.kmz', url: './PARDINHO.kmz' },
             { name: 'PAULINIA.kmz', url: './PAULINIA.kmz' },
             { name: 'PEDERNEIRAS.kmz', url: './PEDERNEIRAS.kmz' },
             { name: 'PEDREGULHO.kmz', url: './PEDREGULHO.kmz' },
             { name: 'PENAPOLIS.kmz', url: './PENAPOLIS.kmz' },
             { name: 'PIACATU.kmz', url: './PIACATU.kmz' },
             { name: 'PIRACICABA SANTA CECILIA.kmz', url: './PIRACICABA SANTA CECILIA.kmz' },
             { name: 'PIRACICABA SANTA TEREZINHA.kmz', url: './PIRACICABA SANTA TEREZINHA.kmz' },
             { name: 'PIRACICABA.kmz', url: './PIRACICABA.kmz' },
             { name: 'PIRAJUI - EA.kmz', url: './PIRAJUI - EA.kmz' },
             { name: 'PIRANGI.kmz', url: './PIRANGI.kmz' },
             { name: 'PITANGUEIRAS.kmz', url: './PITANGUEIRAS.kmz' },
             { name: 'POMPEIA.kmz', url: './POMPEIA.kmz' },
             { name: 'PRESIDENTE ALVES.kmz', url: './PRESIDENTE ALVES.kmz' },
             { name: 'PROMISSAO.kmz', url: './PROMISSAO.kmz' },
             { name: 'RESTINGA.kmz', url: './RESTINGA.kmz' },
             { name: 'RIBEIRAO PRETO NORTE.kmz', url: './RIBEIRAO PRETO NORTE.kmz' },
             { name: 'RIBEIRAO PRETO SUL.kmz', url: './RIBEIRAO PRETO SUL.kmz' },
             { name: 'RINCAO.kmz', url: './RINCAO.kmz' },
             { name: 'SANTA ADELIA.kmz', url: './SANTA ADELIA.kmz' },
             { name: 'SANTA BARBARA DOESTE.kmz', url: './SANTA BARBARA DOESTE.kmz' },
             { name: 'SANTA ROSA DE VITERBO.kmz', url: './SANTA ROSA DE VITERBO.kmz' },
             { name: 'SANTO ANTONIO ARACANGUA.kmz', url: './SANTO ANTONIO ARACANGUA.kmz' },
             { name: 'SAO CARLOS.kmz', url: './SAO CARLOS.kmz' },
             { name: 'SAO JOAQUIM DA BARRA.kmz', url: './SAO JOAQUIM DA BARRA.kmz' },
             { name: 'SAO JOSE RIO PRETO.kmz', url: './SAO JOSE RIO PRETO.kmz' },
             { name: 'SAO MANUEL.kmz', url: './SAO MANUEL.kmz' },
             { name: 'SAO PEDRO.kmz', url: './SAO PEDRO.kmz' },
             { name: 'SAO SIMAO.kmz', url: './SAO SIMAO.kmz' },
             { name: 'SERRA NEGRA.kmz', url: './SERRA NEGRA.kmz' },
             { name: 'SERRANA.kmz', url: './SERRANA.kmz' },
             { name: 'SERTAOZINHO.kmz', url: './SERTAOZINHO.kmz' },
             { name: 'SOCORRO.kmz', url: './SOCORRO.kmz' },
             { name: 'SUMARE.kmz', url: './SUMARE.kmz' },
             { name: 'TANABI.kmz', url: './TANABI.kmz' },
             { name: 'TAQUARITINGA.kmz', url: './TAQUARITINGA.kmz' },
             { name: 'UIRAPURU.kmz', url: './UIRAPURU.kmz' },
             { name: 'VALINHOS.kmz', url: './VALINHOS.kmz' },
             { name: 'VALPARAISO.kmz', url: './VALPARAISO.kmz' },
             { name: 'VIRADOURO.kmz', url: './VIRADOURO.kmz' }
        ];

        function calculateBounds(geojson) {
            let minLng = 180, minLat = 90, maxLng = -180, maxLat = -90;
            function extractCoords(coords) {
                if (typeof coords[0] === 'number' && typeof coords[1] === 'number') {
                    const [lng, lat] = coords;
                    if (lng < minLng) minLng = lng;
                    if (lat < minLat) minLat = lat;
                    if (lng > maxLng) maxLng = lng;
                    if (lat > maxLat) maxLat = lat;
                } else if (Array.isArray(coords)) {
                    coords.forEach(extractCoords);
                }
            }
            geojson.features.forEach(feature => {
                if (feature.geometry && feature.geometry.coordinates) {
                    extractCoords(feature.geometry.coordinates);
                }
            });
            return (minLng > 179) ? null : [minLng, minLat, maxLng, maxLat];
        }

        function boundsIntersect(fileBoundsArray, mapBounds) {
            if (!fileBoundsArray) return false;
            const mapWest = mapBounds.getWest();
            const mapEast = mapBounds.getEast();
            const mapSouth = mapBounds.getSouth();
            const mapNorth = mapBounds.getNorth();
            const fileWest = fileBoundsArray[0];
            const fileSouth = fileBoundsArray[1];
            const fileEast = fileBoundsArray[2];
            const fileNorth = fileBoundsArray[3];
            const noOverlap = fileEast < mapWest || fileWest > mapEast || fileNorth < mapSouth || fileSouth > mapNorth;
            return !noOverlap;
        }

        function getBoundsCenter(bounds) {
            if (!bounds) return null;
            const centerLng = (bounds[0] + bounds[2]) / 2;
            const centerLat = (bounds[1] + bounds[3]) / 2;
            return new maplibregl.LngLat(centerLng, centerLat);
        }

        let updateTimeout;
        async function updateVisibleLayers() {
            clearTimeout(updateTimeout);
            updateTimeout = setTimeout(async () => {
                const mapBounds = map.getBounds();
                const mapCenter = map.getCenter();
                const loadedFileNames = new Set(state.files.map(f => f.name));

                const visibleCandidates = [];
                for (const file of spatialIndex) {
                    if (boundsIntersect(file.bounds, mapBounds)) {
                        const boundsCenter = getBoundsCenter(file.bounds);
                        if (boundsCenter) {
                            const distance = mapCenter.distanceTo(boundsCenter);
                            visibleCandidates.push({ name: file.name, distance: distance });
                        }
                    }
                }

                let filesToDisplay = [];
                if (visibleCandidates.length > 4) {
                    visibleCandidates.sort((a, b) => a.distance - b.distance);
                    filesToDisplay = visibleCandidates.slice(0, 4);
                } else {
                    filesToDisplay = visibleCandidates;
                }

                const requiredFiles = new Set(filesToDisplay.map(f => f.name));
                
                for (const loadedFile of loadedFileNames) {
                    if (!requiredFiles.has(loadedFile)) {
                        removeFileFromMap(loadedFile);
                    }
                }

                for (const requiredFile of requiredFiles) {
                    if (!loadedFileNames.has(requiredFile)) {
                        const data = await getDataFromDB(GEOJSON_STORE_NAME, requiredFile);
                        if (data) {
                            processGeoJSONBatched(data.geojson, data.name, false); 
                        }
                    }
                }
            }, 300);
        }

        function clearMap() {
            const filesToRemove = [...state.files];
            filesToRemove.forEach(file => removeFileFromMap(file.name));
            state.files = [];
            loadedFilesList.innerHTML = '';
            allPointFeatures = [];
            updateVisibleMarkers();
        }

        function updateVisibleMarkers() {
            clearTimeout(updateMarkersTimeout);
            updateMarkersTimeout = setTimeout(() => {
                if (!dynamicMarkerSource) return;

                const mapCenter = map.getCenter();
                const visibleGroups = Object.keys(state.markerGroups).filter(g => state.markerGroups[g].visible);

                const filteredFeatures = allPointFeatures.filter(feature => visibleGroups.includes(feature.properties.group));

                const sortedFeatures = filteredFeatures.map(feature => {
                    if (!feature || !feature.geometry || !Array.isArray(feature.geometry.coordinates) || feature.geometry.coordinates.length < 2) {
                        return { ...feature, properties: { ...feature.properties, distance: Infinity } };
                    }
                    const distance = computeDistance([mapCenter.lng, mapCenter.lat], feature.geometry.coordinates);
                    return { ...feature, properties: { ...feature.properties, distance: distance } };
                }).sort((a, b) => a.properties.distance - b.properties.distance);

                const limit = parseInt(state.visualSettings.markerLimit);
                const limitedFeatures = sortedFeatures.slice(0, limit);

                const geojson = {
                    type: 'FeatureCollection',
                    features: limitedFeatures
                };
                dynamicMarkerSource.setData(geojson);
            }, 150);
        }

        async function parseKMZFromUrl(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Falha ao buscar ${url}`);
                const arrayBuffer = await response.arrayBuffer();
                return await parseKMZ(arrayBuffer);
            } catch (error) {
                throw error;
            }
        }

        async function cacheKMZData(fileName, geojson) {
            try {
                await saveDataToDB(GEOJSON_STORE_NAME, { name: fileName, geojson: geojson });
                
                const bounds = calculateBounds(geojson);
                if (bounds) {
                    await saveDataToDB(SPATIAL_INDEX_STORE_NAME, { name: fileName, bounds: bounds });
                }
                spatialIndex = await getDataFromDB(SPATIAL_INDEX_STORE_NAME);
                displayFileList();
            } catch (e) { console.error(e); }
        }

        async function getKMZFromCache(fileName) {
            const data = await getDataFromDB(GEOJSON_STORE_NAME, fileName);
            if (data && data.geojson) return data.geojson;
            return null;
        }

        map.on('click', (e) => { 
            if (!e.originalEvent.target.closest('.menu, .search-bar, .search-results, .maps-menu, .line-menu, .loaded-files-menu, .style-menu, .marker-group-menu, .maplibregl-popup, .route-panel, .storage-menu, .toggle-menu-btn, .tools-menu, .trail-menu')) {
                mapsMenu.style.display = 'none';
                lineMenu.style.display = 'none';
                loadedFilesMenu.style.display = 'none';
                styleMenu.style.display = 'none';
                searchResults.style.display = 'none';
                markerGroupMenu.style.display = 'none';
                storageMenu.style.display = 'none';
                toolsMenu.style.display = 'none'; 
                trailMenu.style.display = 'none';
            }
        });

        function updateRecentFiles(fileName) {
            let recentFiles = JSON.parse(localStorage.getItem('recentFiles') || '[]');
            recentFiles = recentFiles.filter(f => f !== fileName);
            recentFiles.unshift(fileName);
            recentFiles = recentFiles.slice(0, 5);
            localStorage.setItem('recentFiles', JSON.stringify(recentFiles));
        }

        function updateRecentExternalFiles(fileName) {
            let recentFiles = JSON.parse(localStorage.getItem('recentExternalFiles') || '[]');
            recentFiles = recentFiles.filter(f => f !== fileName);
            recentFiles.unshift(fileName);
            recentFiles = recentFiles.slice(0, 5);
            localStorage.setItem('recentExternalFiles', JSON.stringify(recentFiles));
        }

        async function displayFileList() {
            kmzList.innerHTML = '';
            
            const cachedFiles = new Set();
            if(spatialIndex) {
                spatialIndex.forEach(idx => cachedFiles.add(idx.name));
            }

            const sortedFiles = [...predefinedFiles].sort((a, b) => a.name.localeCompare(b.name));

            sortedFiles.forEach((file) => {
                const li = document.createElement('li');
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = file.name;
                checkbox.className = 'map-select-checkbox';
                checkbox.dataset.url = file.url;
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'file-name';
                nameSpan.textContent = file.name;
                
                const statusSpan = document.createElement('span');
                statusSpan.className = 'map-status';
                
                if (cachedFiles.has(file.name)) {
                    statusSpan.textContent = 'Salvo';
                    statusSpan.classList.add('status-saved');
                } else {
                    statusSpan.textContent = 'Nuvem';
                    statusSpan.classList.add('status-cloud');
                }

                li.appendChild(checkbox);
                li.appendChild(nameSpan);
                li.appendChild(statusSpan);
                
                nameSpan.addEventListener('click', (e) => {
                    e.stopPropagation();
                    loadKMZFromURL(file.url, file.name);
                    updateRecentFiles(file.name);
                });
                
                kmzList.appendChild(li);
            });
        }
        
        function toggleSelectAllMaps() {
            const checkboxes = document.querySelectorAll('.map-select-checkbox');
            const isChecked = chkSelectAllMaps.checked;
            checkboxes.forEach(chk => {
                if(chk.closest('li').style.display !== 'none') {
                    chk.checked = isChecked;
                }
            });
        }

        async function loadSelectedMaps() {
            const checkboxes = document.querySelectorAll('.map-select-checkbox:checked');
            if (checkboxes.length === 0) return alert("Selecione pelo menos um mapa.");
            
            mapsMenu.style.display = 'none'; 
            
            for (let i = 0; i < checkboxes.length; i++) {
                const chk = checkboxes[i];
                const fileName = chk.value;
                const url = chk.dataset.url;
                
                if (state.files.find(f => f.name === fileName)) continue;

                try {
                    await loadKMZFromURL(url, fileName);
                } catch (e) {
                    console.error(`Erro ao carregar lote: ${fileName}`, e);
                }
            }
            alert("Processamento em lote finalizado.");
        }

        chkSelectAllMaps.addEventListener('change', toggleSelectAllMaps);
        btnLoadSelectedMaps.addEventListener('click', loadSelectedMaps);
        
        document.getElementById('mapListSearch').addEventListener('input', function(e) {
            const term = normalizeText(e.target.value);
            const items = kmzList.querySelectorAll('li');
            items.forEach(item => {
                const text = normalizeText(item.querySelector('.file-name').textContent);
                item.style.display = text.includes(term) ? 'flex' : 'none';
            });
        });

        updateMarkerGroupMenu();
        updateSavedTrailsList();

        map.on('load', () => {
            const legends = document.querySelectorAll('.button-legend');
            legends.forEach(legend => { legend.style.display = 'block'; });
            setTimeout(() => { legends.forEach(legend => { legend.style.display = 'none'; }); }, 5000);

            map.addSource('user-trail', { type: 'geojson', data: { type: 'Feature', geometry: { type: 'LineString', coordinates: [] } } });
            map.addLayer({ id: 'user-trail-layer', type: 'line', source: 'user-trail', paint: { 'line-color': '#d63384', 'line-width': 5, 'line-opacity': 0.8 } });

            map.addSource('dynamic-markers', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });
            dynamicMarkerSource = map.getSource('dynamic-markers');

            map.addLayer({
                id: 'dynamic-marker-circles',
                type: 'circle',
                source: 'dynamic-markers',
                paint: {
                    'circle-radius': parseInt(state.visualSettings.markerSize), 
                    'circle-color': ['get', 'color'],
                    'circle-stroke-width': 2,
                    'circle-stroke-color': '#FFFFFF'
                }
            });

            map.addLayer({
                id: 'dynamic-marker-labels',
                type: 'symbol',
                source: 'dynamic-markers',
                layout: {
                    'text-field': ['coalesce', ['get', 'name'], ['get', 'Alimentador']],
                    'text-font': ['Open Sans Bold'], 
                    'text-size': parseInt(state.visualSettings.textSize), 
                    'text-offset': [0, 1.5],
                    'visibility': state.namesVisible ? 'visible' : 'none'
                },
                paint: {
                    'text-color': '#000000',
                    'text-halo-color': '#FFFFFF',
                    'text-halo-width': 2
                }
            });

            map.on('moveend', updateVisibleMarkers);
            toggleAllMarkersVisibilityCheckbox.checked = state.markersVisible;
            toggleAllLinesVisibilityCheckbox.checked = state.linesVisible;

            (async () => {
                try {
                    spatialIndex = await getDataFromDB(SPATIAL_INDEX_STORE_NAME);
                    displayFileList();
                    map.on('moveend', updateVisibleLayers);
                    updateVisibleLayers();
                } catch (e) {
                    console.error("Erro ao inicializar banco de dados:", e);
                }
            })();

            const recentExternalFiles = JSON.parse(localStorage.getItem('recentExternalFiles') || '[]');
            if (recentExternalFiles.length > 0) {
                (async () => {
                    for (const fileName of recentExternalFiles) {
                        const cachedData = await getKMZFromCache(fileName); 
                        if (cachedData) processGeoJSONBatched(cachedData, fileName, false);
                    }
                })();
            }

            map.on('click', 'dynamic-marker-circles', (e) => {
                e.originalEvent.stopPropagation();
                if (!e.features || e.features.length === 0) return;
                const feature = e.features[0];
                const coordinates = feature.geometry.coordinates.slice();
                const properties = feature.properties;
                const displayName = properties.name || properties.Alimentador || 'Sem nome';
                const featureId = feature.id || (properties.name + coordinates.join('')).replace(/[^a-z0-9]/gi, '');

                while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
                    coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
                }

                let popupHTML;
                if (state.isRoutePlanning) {
                    popupHTML = `<div><strong>${displayName}</strong><br><button id="popup-add-route-btn-${featureId}" style="margin-top: 5px; padding: 3px 8px; font-size: 11px; cursor: pointer; background-color: #f7b731; color: black; border: none; border-radius: 3px;">Adicionar √† Rota</button></div>`;
                } else {
                    popupHTML = `<div><strong>${displayName}</strong><br><button id="popup-directions-btn-${featureId}" style="margin-top: 5px; padding: 3px 8px; font-size: 11px; cursor: pointer;">Obter Rota (Google Maps)</button></div>`;
                }

                const popup = new maplibregl.Popup({ closeOnClick: true, offset: 15 }).setLngLat(coordinates).setHTML(popupHTML).addTo(map);
                const popupElement = popup.getElement();

                if (state.isRoutePlanning) {
                    const addRouteBtn = popupElement.querySelector(`#popup-add-route-btn-${featureId}`);
                    if (addRouteBtn) {
                        addRouteBtn.addEventListener('click', () => { addWaypointToRoute(feature); popup.remove(); });
                    }
                } else {
                    const directionsBtn = popupElement.querySelector(`#popup-directions-btn-${featureId}`);
                    if (directionsBtn) {
                        directionsBtn.addEventListener('click', () => {
                            const lat = coordinates[1];
                            const lng = coordinates[0];
                            const url = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&travelmode=driving`;
                            window.open(url, '_blank');
                        });
                    }
                }
            });

            map.on('mouseenter', 'dynamic-marker-circles', () => { map.getCanvas().style.cursor = 'pointer'; });
            map.on('mouseleave', 'dynamic-marker-circles', () => { if (!state.isRoutePlanning) map.getCanvas().style.cursor = ''; });
        }); 

        trailColorInput.addEventListener('input', (e) => {
            if(map.getLayer('user-trail-layer')) map.setPaintProperty('user-trail-layer', 'line-color', e.target.value);
        });

        chkUserTrail.addEventListener('change', (e) => {
            if (e.target.checked) {
                currentTrailCoordinates = [];
                trailPointCount.textContent = '0';
                const chosenColor = trailColorInput.value;
                const interval = parseInt(trailIntervalSelect.value);

                if(map.getLayer('user-trail-layer')) {
                    map.setPaintProperty('user-trail-layer', 'line-color', chosenColor);
                    const source = map.getSource('user-trail');
                    if(source) source.setData({ type: 'Feature', geometry: { type: 'LineString', coordinates: [] } });
                }

                if (navigator.geolocation) {
                    alert(`Iniciando grava√ß√£o (Intervalo: ${interval/1000}s)...`);
                    
                    trailWatchId = navigator.geolocation.watchPosition((pos) => {
                        const now = Date.now();
                        if (now - lastTrailUpdateTime < interval) return;
                        lastTrailUpdateTime = now;

                        const coord = [pos.coords.longitude, pos.coords.latitude];
                        currentTrailCoordinates.push(coord);
                        trailPointCount.textContent = currentTrailCoordinates.length;

                        const source = map.getSource('user-trail');
                        if(source) {
                            source.setData({
                                type: 'Feature',
                                geometry: { type: 'LineString', coordinates: currentTrailCoordinates }
                            });
                        }
                        if(currentTrailCoordinates.length === 1) map.flyTo({ center: coord, zoom: 16 });

                    }, (err) => {
                        console.error("Erro no GPS:", err); alert("Erro ao acessar GPS."); e.target.checked = false;
                    }, { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 });
                } else { alert("GPS n√£o suportado."); e.target.checked = false; }
            } else {
                if (trailWatchId !== null) {
                    navigator.geolocation.clearWatch(trailWatchId);
                    trailWatchId = null;
                    if (currentTrailCoordinates.length > 0) {
                        const trailData = { id: Date.now(), name: `Rastro ${new Date().toLocaleDateString('pt-BR')}`, color: trailColorInput.value, coordinates: [...currentTrailCoordinates] };
                        saveDataToDB(TRAIL_STORE_NAME, trailData).then(() => { alert("Rastro salvo com sucesso!"); updateSavedTrailsList(); });
                    } else { alert("Grava√ß√£o parada. Nenhum ponto capturado."); }
                }
            }
        });

        btnDeleteAllTrails.addEventListener('click', async (e) => {
            e.stopPropagation();
            if(confirm('ATEN√á√ÉO: Isso apagar√° TODOS os rastros salvos. Continuar?')) {
                await clearStore(TRAIL_STORE_NAME);
                updateSavedTrailsList();
                const source = map.getSource('user-trail');
                if(source) source.setData({ type: 'Feature', geometry: { type: 'LineString', coordinates: [] } });
                alert('Hist√≥rico apagado.');
            }
        });

        btnTrailMenu.addEventListener('click', (e) => { e.stopPropagation(); toggleVisibility(trailMenu); });

        document.getElementById('btnMaps').addEventListener('click', (e) => { e.stopPropagation(); toggleVisibility(mapsMenu); });
        
        function toggleNames() {
            state.namesVisible = !state.namesVisible;
            if (map.getLayer('dynamic-marker-labels')) {
                map.setLayoutProperty('dynamic-marker-labels', 'visibility', state.namesVisible ? 'visible' : 'none');
            }
            const btn = document.getElementById('btnNames');
            if (btn) {
                btn.style.backgroundColor = state.namesVisible ? '#ffffff' : '#d1d1d1';
            }
        }

        document.getElementById('btnNames').addEventListener('click', (e) => { 
            e.stopPropagation();
            toggleNames(); 
        });

        document.getElementById('btnReset').addEventListener('click', resetView);
        document.getElementById('btnLocation').addEventListener('click', goToCurrentLocation);
        document.getElementById('btnLineGroups').addEventListener('click', (e) => {
            e.stopPropagation();
            if (state.selectedGroups.size === 0) alert('N√£o h√° grupos de linhas para filtrar.');
            else toggleVisibility(lineMenu);
        });
        btnLoadedFiles.addEventListener('click', (e) => { e.stopPropagation(); toggleVisibility(loadedFilesMenu); });
        document.getElementById('btnSearch').addEventListener('click', searchFeatures);
        
        document.getElementById('selectDevice').addEventListener('click', (e) => { e.stopPropagation(); selectFromDevice(); });
        
        document.getElementById('hideAll').addEventListener('click', hideAllGroups);
        document.getElementById('showAll').addEventListener('click', showAllGroups);
        document.getElementById('btnStyles').addEventListener('click', (e) => { e.stopPropagation(); displayStyleList(); toggleVisibility(styleMenu); });
        document.getElementById('btnMarkerGroups').addEventListener('click', (e) => { e.stopPropagation(); toggleVisibility(markerGroupMenu); });
        btnRoutePlanner.addEventListener('click', (e) => { e.stopPropagation(); toggleRoutePlanning(); });
        btnGenerateRoute.addEventListener('click', generateGoogleMapsUrl);
        btnCancelRoute.addEventListener('click', cancelRoutePlanning);
        document.getElementById('hideAllMarkerGroups').addEventListener('click', () => toggleAllMarkerGroups(false));
        document.getElementById('showAllMarkerGroups').addEventListener('click', () => toggleAllMarkerGroups(true));
        toggleAllMarkersVisibilityCheckbox.addEventListener('change', (e) => { toggleMarkers(e.target.checked); });
        toggleAllLinesVisibilityCheckbox.addEventListener('change', (e) => { toggleLines(e.target.checked); });
        document.getElementById('btnStorageMenu').addEventListener('click', (e) => { e.stopPropagation(); toggleVisibility(storageMenu); });
        btnToggleUI.addEventListener('click', (e) => { e.stopPropagation(); mainMenu.classList.toggle('hidden'); });
        btnTools.addEventListener('click', (e) => { e.stopPropagation(); toggleVisibility(toolsMenu); });

        document.getElementById('lineGroupSearch').addEventListener('input', function(e) {
            const term = normalizeText(e.target.value);
            const items = lineGroupsList.querySelectorAll('li');
            items.forEach(item => {
                const text = normalizeText(item.textContent);
                item.style.display = text.includes(term) ? 'block' : 'none';
            });
        });

        function updateMapVisuals() {
            state.files.forEach(file => {
                if (file.hasLines) {
                    const lineLayerId = `lines-${file.sourceId}`;
                    if (map.getLayer(lineLayerId)) map.setPaintProperty(lineLayerId, 'line-width', parseInt(state.visualSettings.lineWidth));
                }
            });
            if (map.getLayer('dynamic-marker-circles')) map.setPaintProperty('dynamic-marker-circles', 'circle-radius', parseInt(state.visualSettings.markerSize));
            if (map.getLayer('dynamic-marker-labels')) map.setLayoutProperty('dynamic-marker-labels', 'text-size', parseInt(state.visualSettings.textSize));
        }

        rngLineWidth.addEventListener('input', (e) => { valLineWidth.textContent = e.target.value; state.visualSettings.lineWidth = e.target.value; updateMapVisuals(); });
        rngMarkerSize.addEventListener('input', (e) => { valMarkerSize.textContent = e.target.value; state.visualSettings.markerSize = e.target.value; updateMapVisuals(); });
        rngTextSize.addEventListener('input', (e) => { valTextSize.textContent = e.target.value; state.visualSettings.textSize = e.target.value; updateMapVisuals(); });
        rngMarkerLimit.addEventListener('input', (e) => { valMarkerLimit.textContent = e.target.value; state.visualSettings.markerLimit = e.target.value; updateVisibleMarkers(); });

        btnResetOfflineDB.addEventListener('click', (e) => {
            e.stopPropagation();
            if (confirm('TEM CERTEZA? Isso limpar√° o banco de dados.')) {
                indexedDB.deleteDatabase(DB_NAME).onsuccess = () => { alert('Banco limpo.'); location.reload(); };
            }
        });

        btnResetLocalStorage.addEventListener('click', (e) => {
            e.stopPropagation();
            if (confirm('TEM CERTEZA? Isso limpar√° configura√ß√µes.')) { localStorage.clear(); alert('Resetado.'); location.reload(); }
        });

        btnResetAllStorage.addEventListener('click', (e) => {
            e.stopPropagation();
            if (confirm('TEM CERTEZA ABSOLUTA? Reset Total.')) {
                localStorage.clear();
                indexedDB.deleteDatabase(DB_NAME).onsuccess = () => { alert('Tudo limpo.'); location.reload(); };
            }
        });

        document.getElementById('btnSupport').addEventListener('click', (e) => { e.stopPropagation(); window.open('https://chat.whatsapp.com/KmBQvO3u5Pm53cV3XWz2dX', '_blank'); });

        function toggleVisibility(element) {
            [mapsMenu, lineMenu, loadedFilesMenu, styleMenu, markerGroupMenu, routePanel, storageMenu, toolsMenu, trailMenu].forEach(menu => {
                if (menu !== element) {
                    if (menu === routePanel && state.isRoutePlanning) {} else { menu.style.display = 'none'; }
                }
            });
            if ([routePanel, storageMenu, toolsMenu, trailMenu].includes(element)) {
                if (element === routePanel) element.style.display = state.isRoutePlanning ? 'flex' : 'none';
                else element.style.display = (element.style.display === 'flex') ? 'none' : 'flex';
            } else {
                 element.style.display = (element.style.display === 'block') ? 'none' : 'block';
            }
        }

        function selectFromDevice() {
            mapsMenu.style.display = 'none';
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.kml,.kmz';
            input.onchange = handleFile;
            input.click();
        }

        async function loadKMZFromURL(url, fileName) {
            if (typeof gtag === 'function') gtag('event', 'map_load', { 'file_name': fileName, 'load_source': 'server' });
            
            try {
                const cachedData = await getKMZFromCache(fileName); 
                if (cachedData) { 
                    processGeoJSONBatched(cachedData, fileName, false); 
                    return; 
                }
                
                progressOverlay.style.display = 'flex';
                progressText.textContent = "Baixando " + fileName + "...";
                
                const geojson = await parseKMZFromUrl(url);
                if(geojson) {
                    processGeoJSONBatched(geojson, fileName, true); 
                } else {
                    progressOverlay.style.display = 'none';
                }
                
            } catch (error) {
                console.log(`Erro ao carregar "${fileName}":`, error);
                progressOverlay.style.display = 'none';
                alert("Erro ao baixar o mapa: " + fileName);
            }
        }

        function handleFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            if (typeof gtag === 'function') gtag('event', 'map_load', { 'file_name': file.name, 'load_source': 'device' });
            
            progressOverlay.style.display = 'flex';
            progressText.textContent = "Lendo arquivo...";

            const reader = new FileReader();
            reader.onload = async () => {
                try {
                    const data = file.name.endsWith('.kmz') ? await parseKMZ(reader.result) : toGeoJSON.kml(new DOMParser().parseFromString(reader.result, 'text/xml'));
                    processGeoJSONBatched(data, file.name, true);
                    updateRecentExternalFiles(file.name); 
                } catch (error) { 
                    console.error(error);
                    progressOverlay.style.display = 'none';
                    alert('Erro ao processar arquivo.'); 
                }
            };
            if (file.name.endsWith('.kmz')) reader.readAsArrayBuffer(file);
            else reader.readAsText(file);
        }

        async function parseKMZ(data) {
            const zip = await JSZip.loadAsync(data);
            const kmlFile = zip.file(/\.kml$/i)[0];
            if (!kmlFile) throw new Error('KML n√£o encontrado no KMZ.');
            const kmlContent = await kmlFile.async('string');
            return toGeoJSON.kml(new DOMParser().parseFromString(kmlContent, 'text/xml'));
        }

        // ========================================================
        // CORRE√á√ÉO: DETEC√á√ÉO AUTOM√ÅTICA DE "ALIMENTADOR" / "ALIMENTADO" / "LAYER"
        // ========================================================

        async function processGeoJSONBatched(geojson, fileName, saveToDB) {
            const sanitizedFileName = fileName.replace(/\s+/g, '_').replace(/[^\w\-]/g, '');
            const sourceId = `source-${sanitizedFileName}`;
            
            if (state.files.find(file => file.name === fileName)) {
                progressOverlay.style.display = 'none';
                return;
            }

            progressOverlay.style.display = 'flex';
            progressBar.style.width = '0%';
            
            const features = geojson.features;
            const total = features.length;
            let currentIndex = 0;

            const pointFeaturesToAdd = [];
            const lineFeaturesArray = [];
            
            // --- L√ìGICA DE DETEC√á√ÉO MELHORADA ---
            let groupingProperty = null;
            // Lista de propriedades comuns para agrupar
            const potentialProps = ['Alimentador', 'Alimentado', 'ALIMENTADOR', 'Feeder', 'layer'];
            
            // Procura nos primeiros 50 itens para achar um padr√£o (n√£o precisa varrer tudo agora)
            for (let i = 0; i < Math.min(features.length, 50); i++) {
                const f = features[i];
                if (f.properties) {
                    const found = potentialProps.find(p => f.properties[p]);
                    if (found) {
                        groupingProperty = found;
                        break;
                    }
                }
            }
            // Se n√£o achar nada espec√≠fico, usa o 'name' (padr√£o antigo)
            if (!groupingProperty) groupingProperty = 'name';
            // ------------------------------------

            function extractGeometries(feature) {
                const geometries = [];
                if (feature.geometry && feature.geometry.type === 'GeometryCollection') {
                    feature.geometry.geometries.forEach(geom => geometries.push({ ...feature, geometry: geom }));
                } else if (feature.geometry) {
                    geometries.push(feature);
                }
                return geometries;
            }

            function processBatch() {
                const endIndex = Math.min(currentIndex + BATCH_SIZE, total);
                
                for (let i = currentIndex; i < endIndex; i++) {
                    const feature = features[i];
                    const explodedFeatures = extractGeometries(feature);

                    explodedFeatures.forEach(f => {
                        if (!f.geometry) return;

                        if (f.geometry.type === 'Point') {
                            const name = (f.properties.name || '').toUpperCase();
                            let groupKey = 'default';
                            if (name.endsWith('-FU')) groupKey = '-FU';
                            else if (name.endsWith('-FA')) groupKey = '-FA';
                            else if (name.endsWith('-RE')) groupKey = '-RE';
                            else if (name.endsWith('KVA') || name.includes('TR')) groupKey = 'TR';

                            f.properties.group = groupKey;
                            f.properties.color = state.markerGroups[groupKey] ? state.markerGroups[groupKey].color : state.markerGroups['default'].color;
                            f.properties.fileName = fileName;
                            pointFeaturesToAdd.push(f);
                        } 
                        else if (['LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'].includes(f.geometry.type)) {
                            f.properties = f.properties || {};
                            
                            // Tenta pegar o valor da propriedade detectada. Se falhar, usa 'Sem Grupo'
                            const groupName = f.properties[groupingProperty] || 'Outros';
                            
                            let color = groupColorMap.get(groupName);
                            if (!color) {
                                color = colorPalette[groupColorMap.size % colorPalette.length];
                                groupColorMap.set(groupName, color);
                            }
                            f.properties.color = color;
                            lineFeaturesArray.push(f);
                        }
                    });
                }

                currentIndex = endIndex;
                const percentage = Math.round((currentIndex / total) * 100);
                progressBar.style.width = `${percentage}%`;
                progressText.textContent = `Processando: ${currentIndex} / ${total} itens`;

                if (currentIndex < total) {
                    setTimeout(processBatch, 0); 
                } else {
                    saveGroupColorMap(); 
                    finalizeMapLoading(fileName, sourceId, groupingProperty, pointFeaturesToAdd, lineFeaturesArray, geojson, saveToDB);
                }
            }

            setTimeout(processBatch, 0);
        }

        function finalizeMapLoading(fileName, sourceId, groupingProperty, points, lines, originalGeojson, saveToDB) {
            const lineLayerId = `lines-${sourceId}`;

            allPointFeatures.push(...points);

            const lineFeatures = { type: 'FeatureCollection', features: lines };
            
            const groupsSet = new Set();
            if (lines.length > 0 && groupingProperty) {
                lines.forEach(f => {
                    if (f.properties) {
                         // Usa o mesmo fallback 'Outros' definido no loop
                         const val = f.properties[groupingProperty] || 'Outros';
                         groupsSet.add(val);
                    }
                });
            }
            if (groupsSet.size > 0) state.selectedGroups.set(sourceId, new Set(groupsSet));

            const newFileEntry = {
                name: fileName,
                sourceId: sourceId,
                hasLines: lines.length > 0,
                groupingProperty: groupingProperty,
                lineFeatures: lineFeatures
            };
            state.files.push(newFileEntry);

            if (lines.length > 0) {
                const sourceIdLines = sourceId + '-lines';
                if (!map.getSource(sourceIdLines)) map.addSource(sourceIdLines, { type: 'geojson', data: lineFeatures });
                else map.getSource(sourceIdLines).setData(lineFeatures);
                
                if (!map.getLayer(lineLayerId)) { 
                    const layerBelow = map.getLayer('dynamic-marker-circles') ? 'dynamic-marker-circles' : undefined;

                    map.addLayer({ 
                        id: lineLayerId, 
                        type: 'line', 
                        source: sourceIdLines, 
                        paint: { 'line-color': ['get', 'color'], 'line-width': parseInt(state.visualSettings.lineWidth) }, 
                        layout: { 'visibility': state.linesVisible ? 'visible' : 'none' } 
                    }, layerBelow); 
                    
                    map.on('click', lineLayerId, (e) => {
                        e.originalEvent.stopPropagation(); 
                        const feature = e.features[0];
                        const name = feature.properties.Alimentador || feature.properties.name || 'Sem Nome';
                        // Usa a propriedade detectada corretamente
                        const groupName = feature.properties[groupingProperty] || 'Outros';
                        const currentColor = groupColorMap.get(groupName) || '#000000';
                        
                        const popupContainer = document.createElement('div');
                        popupContainer.innerHTML = `<strong>${name}</strong><br><label style="font-size:12px;margin-right:5px">Mudar Cor:</label>`;
                        
                        const colorInput = document.createElement('input');
                        colorInput.type = 'color'; 
                        colorInput.value = currentColor; 
                        colorInput.style.cursor = 'pointer';
                        
                        colorInput.addEventListener('input', (ev) => {
                            applyColorUpdate(groupName, newFileEntry.sourceId, ev.target.value);
                        });
                        
                        popupContainer.appendChild(colorInput);
                        new maplibregl.Popup().setLngLat(e.lngLat).setDOMContent(popupContainer).addTo(map);
                    });

                    map.on('mouseenter', lineLayerId, () => map.getCanvas().style.cursor = 'pointer');
                    map.on('mouseleave', lineLayerId, () => { if (!state.isRoutePlanning) map.getCanvas().style.cursor = ''; });
                }
            }

            updateLoadedFilesList(fileName);
            updateVisibleMarkers(); 
            applyGroupFilter(); 

            state.files.forEach(file => {
                if (file.hasLines) {
                    const lineId = `lines-${file.sourceId}`;
                    if (map.getLayer(lineId)) map.moveLayer(lineId); 
                }
            });
            if (map.getLayer('user-trail-layer')) map.moveLayer('user-trail-layer');
            if (map.getLayer('dynamic-marker-circles')) map.moveLayer('dynamic-marker-circles');
            if (map.getLayer('dynamic-marker-labels')) map.moveLayer('dynamic-marker-labels');

            if (saveToDB) {
                progressText.textContent = "Salvando no Banco de Dados...";
                setTimeout(async () => {
                    await cacheKMZData(fileName, originalGeojson);
                    progressOverlay.style.display = 'none';
                    originalGeojson = null; 
                }, 100);
            } else {
                progressOverlay.style.display = 'none';
            }
            
            points = null;
            lines = null;
        }

        // ========================================================

        function applyColorUpdate(groupName, sourceId, newColor) {
            groupColorMap.set(groupName, newColor);
            saveGroupColorMap();

            const file = state.files.find(f => f.sourceId === sourceId);
            if (!file) return;

            let hasChanges = false;
            file.lineFeatures.features.forEach(feature => {
                const featureGroup = feature.properties[file.groupingProperty];
                if (featureGroup === groupName) {
                    feature.properties.color = newColor;
                    hasChanges = true;
                }
            });

            if (hasChanges) {
                const source = map.getSource(file.sourceId + '-lines');
                if (source) {
                    source.setData(file.lineFeatures);
                }
            }

            try {
                const menuInputs = document.querySelectorAll(`input[type="color"][data-group-name="${groupName}"][data-source-id="${sourceId}"]`);
                menuInputs.forEach(input => input.value = newColor);
            } catch(e) { console.log("Erro ao atualizar input do menu"); }
        }

        function handleColorChange(event) {
            applyColorUpdate(event.target.dataset.groupName, event.target.dataset.sourceId, event.target.value);
        }

        function changeMarkerGroupColor(groupKey, newColor) {
            if (state.markerGroups[groupKey]) state.markerGroups[groupKey].color = newColor;
            const colorsToSave = {};
            Object.keys(state.markerGroups).forEach(key => colorsToSave[key] = state.markerGroups[key].color);
            localStorage.setItem('markerGroupColors', JSON.stringify(colorsToSave));
            allPointFeatures.forEach(feature => {
                if (feature.properties.group === groupKey) feature.properties.color = newColor;
            });
            updateVisibleMarkers();
            const labelText = document.querySelector(`label[data-group-label="${groupKey}"] span`);
            if(labelText) labelText.style.color = newColor;
        }

        function removeFileFromMap(fileName) {
            const fileIndex = state.files.findIndex(file => file.name === fileName);
            if (fileIndex === -1) return;
            const file = state.files[fileIndex];
            const sourceId = file.sourceId;
            allPointFeatures = allPointFeatures.filter(feature => feature.properties.fileName !== fileName);

            if (file.hasLines) {
                const lineLayerId = `lines-${sourceId}`;
                if (map.getLayer(lineLayerId)) map.removeLayer(lineLayerId);
                if (map.getSource(sourceId + '-lines')) map.removeSource(sourceId + '-lines');
            }
            if (file.hasLines && file.groupingProperty && state.selectedGroups.has(sourceId)) state.selectedGroups.delete(sourceId);
            const liToRemove = [...loadedFilesList.children].find(li => li.textContent.startsWith(fileName));
            if (liToRemove) liToRemove.remove();
            state.files.splice(fileIndex, 1);
            
            updateGroupMenu();
            updateVisibleMarkers();
        }

        function updateGroupMenu() {
            lineGroupsList.innerHTML = '';
            state.files.forEach(file => {
                if (file.hasLines && file.groupingProperty) {
                    const selectedFileGroups = state.selectedGroups.get(file.sourceId) || new Set();
                    const fileHeader = document.createElement('div');
                    fileHeader.style.fontWeight = 'bold'; fileHeader.style.marginTop = '10px'; fileHeader.textContent = `Arquivo: "${file.name}"`;
                    lineGroupsList.appendChild(fileHeader);
                    const allFileGroups = new Set();
                    file.lineFeatures.features.forEach(feature => { if (feature.properties && feature.properties[file.groupingProperty]) allFileGroups.add(feature.properties[file.groupingProperty]); });
                    const sortedGroups = Array.from(allFileGroups).sort((a, b) => a.localeCompare(b));
                    sortedGroups.forEach(grp => {
                        const li = document.createElement('li');
                        const lbl = document.createElement('label');
                        lbl.style.display = 'flex'; lbl.style.alignItems = 'center';
                        const chk = document.createElement('input');
                        chk.type = 'checkbox'; chk.value = grp; chk.checked = selectedFileGroups.has(grp);
                        const groupColor = groupColorMap.get(grp);
                        if (groupColor) { lbl.style.color = groupColor; lbl.style.fontWeight = 'bold'; }
                        chk.onchange = () => { const currentGroups = state.selectedGroups.get(file.sourceId); if (chk.checked) currentGroups.add(grp); else currentGroups.delete(grp); applyGroupFilter(); };
                        lbl.appendChild(chk); lbl.appendChild(document.createTextNode(' ' + grp));
                        const colorPicker = document.createElement('input');
                        colorPicker.type = 'color'; colorPicker.value = groupColor || '#CCCCCC'; colorPicker.style.marginLeft = 'auto'; colorPicker.style.padding = '0'; colorPicker.style.border = 'none'; colorPicker.style.width = '30px'; colorPicker.style.height = '20px'; colorPicker.style.cursor = 'pointer';
                        colorPicker.dataset.groupName = grp; colorPicker.dataset.sourceId = file.sourceId;
                        colorPicker.onchange = handleColorChange; colorPicker.onclick = (e) => e.stopPropagation(); 
                        lbl.appendChild(colorPicker); li.appendChild(lbl); lineGroupsList.appendChild(li);
                    });
                }
            });
        }
        
        function updateMarkerGroupMenu() {
            markerGroupsList.innerHTML = '';
            Object.keys(state.markerGroups).forEach(groupKey => {
                if (groupKey === 'default') return;
                const group = state.markerGroups[groupKey];
                const li = document.createElement('li');
                const lbl = document.createElement('label');
                lbl.style.display = 'flex'; lbl.style.alignItems = 'center'; lbl.style.width = '100%'; lbl.dataset.groupLabel = groupKey;
                const chk = document.createElement('input');
                chk.type = 'checkbox'; chk.checked = group.visible; chk.style.marginRight = '10px';
                chk.onchange = () => { state.markerGroups[groupKey].visible = chk.checked; updateVisibleMarkers(); };
                const textSpan = document.createElement('span');
                textSpan.textContent = groupKey; textSpan.style.fontWeight = 'bold'; textSpan.style.color = group.color; textSpan.style.flexGrow = '1';
                const colorInput = document.createElement('input');
                colorInput.type = 'color'; colorInput.value = group.color; colorInput.style.border = 'none'; colorInput.style.width = '30px'; colorInput.style.height = '25px'; colorInput.style.padding = '0'; colorInput.style.cursor = 'pointer'; colorInput.style.background = 'none';
                colorInput.addEventListener('input', (e) => { textSpan.style.color = e.target.value; changeMarkerGroupColor(groupKey, e.target.value); });
                colorInput.addEventListener('click', (e) => e.stopPropagation());
                lbl.appendChild(chk); lbl.appendChild(textSpan); lbl.appendChild(colorInput);
                li.appendChild(lbl); markerGroupsList.appendChild(li);
            });
        }

        function applyMarkerGroupFilter() { updateVisibleMarkers(); }
        function toggleAllMarkerGroups(visible) { Object.keys(state.markerGroups).forEach(groupKey => { state.markerGroups[groupKey].visible = visible; }); updateMarkerGroupMenu(); updateVisibleMarkers(); }
        
        function toggleMarkers(visible) {
            state.markersVisible = (typeof visible === 'boolean') ? visible : !state.markersVisible;
            if(toggleAllMarkersVisibilityCheckbox) toggleAllMarkersVisibilityCheckbox.checked = state.markersVisible;
            if (map.getLayer('dynamic-marker-circles')) {
                map.setLayoutProperty('dynamic-marker-circles', 'visibility', state.markersVisible ? 'visible' : 'none');
            }
        }

        function updateLoadedFilesList(fileName) {
            const li = document.createElement('li'); li.textContent = fileName;
            const removeBtn = document.createElement('button'); removeBtn.textContent = 'Remover';
            removeBtn.addEventListener('click', () => removeFileFromMap(fileName));
            li.appendChild(removeBtn);
            const existingLi = [...loadedFilesList.children].find(child => child.textContent.startsWith(fileName));
            if (!existingLi) loadedFilesList.appendChild(li);
        }

        function applyGroupFilter() {
            state.files.forEach(file => {
                if (!file.hasLines || !file.groupingProperty) return;
                const lineLayerId = `lines-${file.sourceId}`;
                const selectedGroups = state.selectedGroups.get(file.sourceId);
                if (!map.getLayer(lineLayerId)) return; 
                if (!selectedGroups || selectedGroups.size === 0) map.setFilter(lineLayerId, ["==", file.groupingProperty, "___no_match___"]);
                else map.setFilter(lineLayerId, ["in", file.groupingProperty, ...Array.from(selectedGroups)]);
            });
        }

        function hideAllGroups() {
            state.selectedGroups.forEach((groups, sourceId) => state.selectedGroups.set(sourceId, new Set()));
            document.querySelectorAll('#lineGroupsList input[type=checkbox]').forEach(chk => chk.checked = false);
            applyGroupFilter();
        }

        function showAllGroups() {
            state.files.forEach(file => {
                if (file.hasLines && file.groupingProperty) {
                    const allGroups = new Set();
                    if (file.lineFeatures && file.lineFeatures.features) {
                        file.lineFeatures.features.forEach(feature => { if (feature.properties && feature.properties[file.groupingProperty]) allGroups.add(feature.properties[file.groupingProperty]); });
                        state.selectedGroups.set(file.sourceId, new Set(allGroups));
                    }
                }
            });
            document.querySelectorAll('#lineGroupsList input[type=checkbox]').forEach(chk => chk.checked = true);
            applyGroupFilter();
        }

        function toggleLines(visible) {
            state.linesVisible = (typeof visible === 'boolean') ? visible : !state.linesVisible;
            toggleAllLinesVisibilityCheckbox.checked = state.linesVisible;
            state.files.forEach(file => {
                if (file.hasLines) {
                    const lineLayerId = `lines-${file.sourceId}`;
                    if (map.getLayer(lineLayerId)) map.setLayoutProperty(lineLayerId, 'visibility', state.linesVisible ? 'visible' : 'none'); 
                }
            });
        }
        
        function resetView() { map.easeTo({ center: [-47.068847, -22.934973], zoom: 11 }); }

        function changeMapStyle(newStyleUrlOrObject) {
            map.setStyle(newStyleUrlOrObject);

            map.once('styledata', () => {
                if (!map.getSource('dynamic-markers')) {
                    map.addSource('dynamic-markers', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });
                    dynamicMarkerSource = map.getSource('dynamic-markers');
                }
                if (!map.getLayer('dynamic-marker-circles')) {
                    map.addLayer({
                        id: 'dynamic-marker-circles', type: 'circle', source: 'dynamic-markers',
                        paint: { 'circle-radius': parseInt(state.visualSettings.markerSize), 'circle-color': ['get', 'color'], 'circle-stroke-width': 2, 'circle-stroke-color': '#FFFFFF' }
                    });
                }
                if (!map.getLayer('dynamic-marker-labels')) {
                    map.addLayer({
                        id: 'dynamic-marker-labels', type: 'symbol', source: 'dynamic-markers',
                        layout: { 'text-field': ['coalesce', ['get', 'name'], ['get', 'Alimentador']], 'text-font': ['Open Sans Bold'], 'text-size': parseInt(state.visualSettings.textSize), 'text-offset': [0, 1.5], 'visibility': state.namesVisible ? 'visible' : 'none' },
                        paint: { 'text-color': '#000000', 'text-halo-color': '#FFFFFF', 'text-halo-width': 2 }
                    });
                }

                state.files.forEach(file => {
                    if (file.hasLines) {
                        const sourceIdLines = file.sourceId + '-lines';
                        const lineLayerId = `lines-${file.sourceId}`;
                        
                        if (!map.getSource(sourceIdLines)) map.addSource(sourceIdLines, { type: 'geojson', data: file.lineFeatures });
                        if (!map.getLayer(lineLayerId)) {
                             map.addLayer({ 
                                 id: lineLayerId, type: 'line', source: sourceIdLines, 
                                 paint: { 'line-color': ['get', 'color'], 'line-width': parseInt(state.visualSettings.lineWidth) }, 
                                 layout: { 'visibility': state.linesVisible ? 'visible' : 'none' } 
                             });
                        }
                    }
                });

                state.files.forEach(file => { if (file.hasLines) { const lineId = `lines-${file.sourceId}`; if (map.getLayer(lineId)) map.moveLayer(lineId); } });
                if (map.getLayer('user-trail-layer')) map.moveLayer('user-trail-layer');
                if (map.getLayer('dynamic-marker-circles')) map.moveLayer('dynamic-marker-circles');
                if (map.getLayer('dynamic-marker-labels')) map.moveLayer('dynamic-marker-labels');

                updateVisibleMarkers();
                applyGroupFilter();
                toggleLines(state.linesVisible);
                if(map.getLayer('dynamic-marker-labels')) {
                    map.setLayoutProperty('dynamic-marker-labels', 'visibility', state.namesVisible ? 'visible' : 'none');
                }
            });
        }

        function displayStyleList() {
            const styleList = document.getElementById('styleList');
            styleList.innerHTML = '';
            mapStyles.forEach(style => {
                const li = document.createElement('li');
                li.textContent = style.name;
                li.addEventListener('click', () => { changeMapStyle(style.url || style.style); styleMenu.style.display = 'none'; });
                styleList.appendChild(li);
            });
        }

        function normalizeText(text) {
             if (!text) return '';
             return text.toString().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/[^a-z0-9]/g, '');
        }

        function getFeatureCenter(feature) {
            if (!feature || !feature.geometry) return null;
            if (feature.geometry.type === 'Point') {
                if (feature.geometry.coordinates.length >= 2) return feature.geometry.coordinates;
                return null;
            }
            let coords = [];
            const extract = (list) => {
                if (Array.isArray(list[0])) list.forEach(extract);
                else if (list.length >= 2 && typeof list[0] === 'number') coords.push(list);
            };
            extract(feature.geometry.coordinates);
            if (coords.length === 0) return null;
            const avgLng = coords.reduce((sum, p) => sum + p[0], 0) / coords.length;
            const avgLat = coords.reduce((sum, p) => sum + p[1], 0) / coords.length;
            return [avgLng, avgLat];
        }

        async function searchFeatures() {
            const term = searchInput.value.toLowerCase().trim();
            if (!term) return alert('Digite um termo para buscar.');

            const btn = document.getElementById('btnSearch');
            const originalText = btn.textContent;
            btn.textContent = 'Buscando...';
            btn.disabled = true;

            const normalizedTerm = normalizeText(term);
            const matches = [];

            try {
                const db = await openDB();
                const transaction = db.transaction([GEOJSON_STORE_NAME], 'readonly');
                const store = transaction.objectStore(GEOJSON_STORE_NAME);

                await new Promise((resolve, reject) => {
                    const request = store.openCursor();
                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            const fileData = cursor.value; 
                            if (fileData.geojson && Array.isArray(fileData.geojson.features)) {
                                for (const feature of fileData.geojson.features) {
                                    const p = feature.properties || {};
                                    const name = p.name || p.Alimentador || '';
                                    if (name && normalizeText(name).includes(normalizedTerm)) {
                                        const featureResult = JSON.parse(JSON.stringify(feature));
                                        featureResult.properties.fileName = fileData.name;
                                        matches.push(featureResult);
                                    }
                                    if (matches.length >= 20) { resolve(); return; }
                                }
                            }
                            cursor.continue();
                        } else { resolve(); }
                    };
                    request.onerror = () => reject(request.error);
                });

                displaySearchResults(matches);

            } catch (err) {
                console.error("Erro na busca:", err);
                alert("Erro ao buscar no banco de dados.");
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        function displaySearchResults(results) {
            searchResults.innerHTML = '';
            if (results.length === 0) {
                 searchResults.style.display = 'none';
                 return alert('Nenhum resultado encontrado.');
            }
            const ul = document.createElement('ul');
            results.forEach(result => {
                const li = document.createElement('li');
                const name = result.properties.name || result.properties.Alimentador || 'Sem nome';
                const fileName = result.properties.fileName || '';
                
                const infoDiv = document.createElement('div');
                infoDiv.className = 'result-info';
                infoDiv.innerHTML = `<strong>${name}</strong><br><small style="color:#666">${fileName}</small>`;
                
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'result-actions';

                const btnVer = document.createElement('button');
                btnVer.textContent = 'Ver';
                btnVer.onclick = (e) => {
                    e.stopPropagation();
                    const center = getFeatureCenter(result);
                    
                    if(center) { 
                        map.flyTo({ center: center, zoom: 16 }); 
                        searchResults.style.display = 'none'; 

                        const coordinates = center;
                        const properties = result.properties;
                        const displayName = properties.name || properties.Alimentador || 'Sem nome';
                        const featureId = result.id || (displayName + coordinates.join('')).replace(/[^a-z0-9]/gi, '');

                        let popupHTML;
                        if (state.isRoutePlanning) {
                            popupHTML = `<div><strong>${displayName}</strong><br><button id="popup-add-route-btn-${featureId}" style="margin-top: 5px; padding: 3px 8px; font-size: 11px; cursor: pointer; background-color: #f7b731; color: black; border: none; border-radius: 3px;">Adicionar √† Rota</button></div>`;
                        } else {
                            popupHTML = `<div><strong>${displayName}</strong><br><button id="popup-directions-btn-${featureId}" style="margin-top: 5px; padding: 3px 8px; font-size: 11px; cursor: pointer;">Obter Rota (Google Maps)</button></div>`;
                        }

                        const popup = new maplibregl.Popup({ closeOnClick: true, offset: 15 }).setLngLat(coordinates).setHTML(popupHTML).addTo(map);
                        const popupElement = popup.getElement();

                        if (state.isRoutePlanning) {
                            const addRouteBtn = popupElement.querySelector(`#popup-add-route-btn-${featureId}`);
                            if (addRouteBtn) {
                                addRouteBtn.addEventListener('click', () => { addWaypointToRoute(result); popup.remove(); });
                            }
                        } else {
                            const directionsBtn = popupElement.querySelector(`#popup-directions-btn-${featureId}`);
                            if (directionsBtn) {
                                directionsBtn.addEventListener('click', () => {
                                    const url = `https://www.google.com/maps/dir/?api=1&destination=${coordinates[1]},${coordinates[0]}&travelmode=driving`;
                                    window.open(url, '_blank');
                                });
                            }
                        }

                    } else { alert('Localiza√ß√£o inv√°lida.'); }
                };

                const btnRota = document.createElement('button');
                btnRota.textContent = 'Rota';
                btnRota.style.backgroundColor = '#34A853'; 
                btnRota.onclick = (e) => {
                    e.stopPropagation();
                    const center = getFeatureCenter(result);
                    if (center) {
                        const url = `https://www.google.com/maps/dir/?api=1&destination=${center[1]},${center[0]}&travelmode=driving`;
                        window.open(url, '_blank');
                    } else { alert('Coordenadas inv√°lidas.'); }
                };

                actionsDiv.appendChild(btnVer);
                actionsDiv.appendChild(btnRota);
                li.appendChild(infoDiv);
                li.appendChild(actionsDiv);
                ul.appendChild(li);
            });
            searchResults.appendChild(ul);
            searchResults.style.display = 'block';
        }

        function computeDistance(coord1, coord2) {
             const toRad = (value) => value * Math.PI / 180;
             const R = 6371e3; 
             const œÜ1 = toRad(coord1[1]), œÜ2 = toRad(coord2[1]);
             const ŒîœÜ = toRad(coord2[1] - coord1[1]), ŒîŒª = toRad(coord2[0] - coord1[0]);
             const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
             return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        function goToCurrentLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition((pos) => {
                    const coords = [pos.coords.longitude, pos.coords.latitude];
                    state.userLocation = coords;
                    map.flyTo({ center: coords, zoom: 16 });
                    new maplibregl.Marker({ color: 'blue' }).setLngLat(coords).addTo(map);
                }, () => alert('Erro ao obter localiza√ß√£o.'));
            } else alert('Geolocaliza√ß√£o n√£o suportada.');
        }

        function toggleRoutePlanning() {
            state.isRoutePlanning = !state.isRoutePlanning;
            if (state.isRoutePlanning) {
                routePanel.style.display = 'flex';
                btnRoutePlanner.classList.add('active');
                map.getCanvas().style.cursor = 'crosshair';
                updateRoutePanelUI();
            } else {
                cancelRoutePlanning();
            }
        }

        function addWaypointToRoute(feature) {
             if (routeWaypoints.length >= MAX_WAYPOINTS) return alert('M√°ximo de pontos atingido.');
             const coords = feature.geometry.coordinates.slice();
             const name = feature.properties.name || 'Ponto';
             routeWaypoints.push({ name: name, coordinates: coords });
             const m = new maplibregl.Marker({ color: '#f7b731' }).setLngLat(coords).addTo(map);
             routeMarkers.push(m);
             updateRoutePanelUI();
        }

        function updateRoutePanelUI() {
             routeList.innerHTML = '';
             routeWaypoints.forEach((wp, i) => {
                 const li = document.createElement('li');
                 li.innerHTML = `<span>${wp.name}</span> <button class="remove-wp" onclick="removeWaypoint(${i})">X</button>`;
                 routeList.appendChild(li);
             });
             routeCounter.textContent = `Pontos: ${routeWaypoints.length} / ${MAX_WAYPOINTS}`;
        }
        
        window.removeWaypoint = function(index) { 
             routeWaypoints.splice(index, 1);
             if(routeMarkers[index]) routeMarkers[index].remove();
             routeMarkers.splice(index, 1);
             updateRoutePanelUI();
        };

        function cancelRoutePlanning() {
             routeMarkers.forEach(m => m.remove());
             routeMarkers = [];
             routeWaypoints = [];
             updateRoutePanelUI();
             routePanel.style.display = 'none';
             state.isRoutePlanning = false;
             btnRoutePlanner.classList.remove('active');
             map.getCanvas().style.cursor = '';
        }

        function generateGoogleMapsUrl() {
             if (routeWaypoints.length < 1) return alert("Adicione pontos.");
             const dest = routeWaypoints[routeWaypoints.length - 1];
             let url = `https://www.google.com/maps/dir/?api=1&destination=${dest.coordinates[1]},${dest.coordinates[0]}&travelmode=driving`;
             if (routeWaypoints.length > 1) {
                 const wps = routeWaypoints.slice(0, -1).map(wp => `${wp.coordinates[1]},${wp.coordinates[0]}`).join('|');
                 url += `&waypoints=${wps}`;
             }
             window.open(url, '_blank');
             cancelRoutePlanning();
        }

        const menuButtons = document.querySelectorAll('.menu button');
        menuButtons.forEach(button => {
            button.addEventListener('mouseover', () => { const l = button.querySelector('.button-legend'); if (l) l.style.display = 'block'; });
            button.addEventListener('mouseout', () => { const l = button.querySelector('.button-legend'); if (l) l.style.display = 'none'; });
        });
    </script>
</body>
</html>