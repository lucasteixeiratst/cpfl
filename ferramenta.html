<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Visualizador de KMZ</title>
    <link href="https://unpkg.com/maplibre-gl@5.6.0/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@5.6.0/dist/maplibre-gl.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://unpkg.com/@tmcw/togeojson@5.8.1/togeojson.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: Arial, sans-serif;
            position: relative;
        }
        #map {
            height: 100%;
            width: 100%;
        }
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        button {
            padding: 10px;
            background-color: #4285F4;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover {
            background-color: #357ae8;
        }
        .status {
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: flex;
            gap: 10px;
        }
        .status div {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }
        input[type="file"] {
            display: none;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="controls">
        <button id="upload-btn">Upload KMZ</button>
        <button id="location-btn">Minha Localização</button>
        <input type="file" id="file-input" accept=".kmz,.kml" />
    </div>
    <div class="status">
        <div id="db-status" title="Status do Banco de Dados"></div>
        <div id="api-status" title="Status da API"></div>
    </div>

    <script>
        // Configuração do Supabase
        const supabaseUrl = 'https://apwforodphfoorwhaqdo.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFwd2Zvcm9kcGhmb29yd2hhcWRvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDkwODQ5ODcsImV4cCI6MjA2NDY2MDk4N30.lmLDwaDpYPs32K5fL-aU8wgMJy5U8za0r91jJCiT9vc';
        const supabase = Supabase.createClient(supabaseUrl, supabaseKey);

        // Inicializar o mapa
        const map = new maplibregl.Map({
            container: 'map',
            style: 'https://demotiles.maplibre.org/style.json',
            center: [-47.068847, -22.934973],
            zoom: 11
        });

        // Estado para rastrear camadas carregadas
        const state = {
            loadedFeatures: {}
        };

        // Verificar conexão com o banco de dados
        async function checkDatabaseConnection() {
            try {
                const { data, error } = await supabase.from('kmz_files').select('*').limit(1);
                if (error) throw error;
                document.getElementById('db-status').style.backgroundColor = 'green';
            } catch (error) {
                console.error('Erro na conexão com o banco de dados:', error);
                document.getElementById('db-status').style.backgroundColor = 'red';
            }
        }

        // Verificar conexão com a API
        async function checkApiConnection() {
            try {
                const response = await fetch(`${supabaseUrl}/rest/v1/`, {
                    headers: {
                        'Authorization': `Bearer ${supabaseKey}`,
                        'apikey': supabaseKey
                    }
                });
                if (response.ok) {
                    document.getElementById('api-status').style.backgroundColor = 'green';
                } else {
                    throw new Error('Falha na requisição à API');
                }
            } catch (error) {
                console.error('Erro na conexão com a API:', error);
                document.getElementById('api-status').style.backgroundColor = 'red';
            }
        }

        // Evento para abrir o input de arquivo
        document.getElementById('upload-btn').addEventListener('click', () => {
            document.getElementById('file-input').click();
        });

        // Evento para processar o arquivo
        document.getElementById('file-input').addEventListener('change', handleFileUpload);

        // Evento para localização
        document.getElementById('location-btn').addEventListener('click', getLocation);

        // Processar arquivo KMZ/KML
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                let geojson;
                if (file.name.endsWith('.kmz')) {
                    const zip = await JSZip.loadAsync(file);
                    const kmlFile = zip.file(/\.kml$/i)[0];
                    if (!kmlFile) throw new Error('Nenhum arquivo KML encontrado no KMZ');
                    const kmlContent = await kmlFile.async('string');
                    const kmlDoc = new DOMParser().parseFromString(kmlContent, 'text/xml');
                    geojson = toGeoJSON.kml(kmlDoc);
                } else if (file.name.endsWith('.kml')) {
                    const reader = new FileReader();
                    reader.readAsText(file);
                    geojson = await new Promise((resolve) => {
                        reader.onload = () => {
                            const kmlDoc = new DOMParser().parseFromString(reader.result, 'text/xml');
                            resolve(toGeoJSON.kml(kmlDoc));

                        };
                    });
                } else {
                    throw new Error('Formato de arquivo não suportado. Use KMZ ou KML.');
                }
                await uploadToSupabase(geojson, file.name);
                loadMapData();
                alert('Arquivo enviado com sucesso!');
            } catch (error) {
                console.error('Erro ao processar o arquivo:', error);
                alert('Erro ao processar o arquivo. Verifique o console.');
            }
        }

        // Enviar dados para o Supabase
        async function uploadToSupabase(geojson, fileName) {
            const { data: kmzFile, error: fileError } = await supabase
                .from('kmz_files')
                .insert([{ name: fileName }])
                .select()
                .single();
            if (fileError) throw fileError;

            for (const feature of geojson.features) {
                if (feature.geometry.type === 'Point') {
                    const { error } = await supabase.from('markers').insert([{
                        kmz_file_id: kmzFile.id,
                        name: feature.properties.name,
                        description: feature.properties.description,
                        coordinates: feature.geometry
                    }]);
                    if (error) throw error;
                } else if (feature.geometry.type === 'LineString') {
                    const { error } = await supabase.from('lines').insert([{
                        kmz_file_id: kmzFile.id,
                        name: feature.properties.name,
                        description: feature.properties.description,
                        coordinates: feature.geometry,
                        color: feature.properties.color || '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0')
                    }]);
                    if (error) throw error;
                } else if (feature.geometry.type === 'Polygon') {
                    const { error } = await supabase.from('polygons').insert([{
                        kmz_file_id: kmzFile.id,
                        name: feature.properties.name,
                        description: feature.properties.description,
                        coordinates: feature.geometry,
                        color: feature.properties.color || '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, Juno                    if (error) throw error;
                }
            }
        }

        // Carregar dados do mapa
        async function loadMapData() {
            const bounds = map.getBounds();
            const sw = bounds.getSouthWest();
            const ne = bounds.getNorthEast();
            const bbox = `POLYGON((${sw.lng} ${sw.lat}, ${ne.lng} ${sw.lat}, ${ne.lng} ${ne.lat}, ${sw.lng} ${ne.lat}, ${sw.lng} ${sw.lat}))`;

            clearMapLayers();

            const { data: markers, error: markersError } = await supabase
                .from('markers')
                .select('id, name, description, coordinates')
                .filter('coordinates', 'st_intersects', bbox);
            if (markersError) throw markersError;
            if (markers) addMarkersToMap(markers);

            const { data: lines, error: linesError } = await supabase
                .from('lines')
                .select('id, name, description, coordinates, color')
                .filter('coordinates', 'st_intersects', bbox);
            if (linesError) throw linesError;
            if (lines) addLinesToMap(lines);

            const { data: polygons, error: polygonsError } = await supabase
                .from('polygons')
                .select('id, name, description, coordinates, color')
                .filter('coordinates', 'st_intersects', bbox);
            if (polygonsError) throw polygonsError;
            if (polygons) addPolygonsToMap(polygons);
        }

        // Limpar camadas do mapa
        function clearMapLayers() {
            for (const [id] of Object.entries(state.loadedFeatures)) {
                if (map.getLayer(id)) map.removeLayer(id);
                if (map.getSource(id)) map.removeSource(id);
            }
            state.loadedFeatures = {};
        }

        // Adicionar marcadores ao mapa
        function addMarkersToMap(markers) {
            if (!markers || markers.length === 0) return;
            const geojson = {
                type: 'FeatureCollection',
                features: markers.map(marker => ({
                    type: 'Feature',
                    properties: { id: marker.id, name: marker.name, description: marker.description },
                    geometry: marker.coordinates
                }))
            };
            const sourceId = 'markers-source';
            const markerLayerId = 'markers-layer';
            if (!map.getSource(sourceId)) {
                map.addSource(sourceId, { type: 'geojson', data: geojson });
                map.addLayer({
                    id: markerLayerId,
                    type: 'circle',
                    source: sourceId,
                    paint: {
                        'circle-radius': 5,
                        'circle-color': '#007cbf'
                    }
                });
                state.loadedFeatures[markerLayerId] = 'marker';
                state.loadedFeatures[sourceId] = 'source';
            } else {
                map.getSource(sourceId).setData(geojson);
            }
        }

        // Adicionar linhas ao mapa
        function addLinesToMap(lines) {
            if (!lines || lines.length === 0) return;
            const geojson = {
                type: 'FeatureCollection',
                features: lines.map(line => ({
                    type: 'Feature',
                    properties: { id: line.id, name: line.name, description: line.description, color: line.color },
                    geometry: line.coordinates
                }))
            };
            const sourceId = 'lines-source';
            const lineLayerId = 'lines-layer';
            if (!map.getSource(sourceId)) {
                map.addSource(sourceId, { type: 'geojson', data: geojson });
                map.addLayer({
                    id: lineLayerId,
                    type: 'line',
                    source: sourceId,
                    paint: {
                        'line-color': ['get', 'color'],
                        'line-width': 2
                    }
                });
                state.loadedFeatures[lineLayerId] = 'line';
                state.loadedFeatures[sourceId] = 'source';
            } else {
                map.getSource(sourceId).setData(geojson);
            }
        }

        // Adicionar polígonos ao mapa
        function addPolygonsToMap(polygons) {
            if (!polygons || polygons.length === 0) return;
            const geojson = {
                type: 'FeatureCollection',
                features: polygons.map(polygon => ({
                    type: 'Feature',
                    properties: { id: polygon.id, name: polygon.name, description: polygon.description, color: polygon.color },
                    geometry: polygon.coordinates
                }))
            };
            const sourceId = 'polygons-source';
            const polygonLayerId = 'polygons-layer';
            if (!map.getSource(sourceId)) {
                map.addSource(sourceId, { type: 'geojson', data: geojson });
                map.addLayer({
                    id: polygonLayerId,
                    type: 'fill',
                    source: sourceId,
                    paint: {
                        'fill-color': ['get', 'color'],
                        'fill-opacity': 0.5
                    }
                });
                state.loadedFeatures[polygonLayerId] = 'polygon';
                state.loadedFeatures[sourceId] = 'source';
            } else {
                map.getSource(sourceId).setData(geojson);
            }
        }

        // Obter localização do usuário
        function getLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(showPosition, showError);
            } else {
                alert('Geolocalização não suportada pelo navegador.');
            }
        }

        // Exibir localização do usuário
        function showPosition(position) {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            map.flyTo({ center: [lng, lat], zoom: 15 });
            new maplibregl.Marker({ color: '#FF0000' })
                .setLngLat([lng, lat])
                .addTo(map);
        }

        // Lidar com erros de geolocalização
        function showError(error) {
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    alert('Permissão de geolocalização negada.');
                    break;
                case error.POSITION_UNAVAILABLE:
                    alert('Informação de localização indisponível.');
                    break;
                case error.TIMEOUT:
                    alert('Tempo esgotado para obter localização.');
                    break;
                default:
                    alert('Erro desconhecido.');
                    break;
            }
        }

        // Carregar dados ao inicializar o mapa
        map.on('load', () => {
            checkDatabaseConnection();
            checkApiConnection();
            loadMapData();
        });

        // Atualizar dados ao mover o mapa
        map.on('moveend', loadMapData);
    </script>
</body>
</html>
