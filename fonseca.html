<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Visualizador de Mapas Profissional</title>
    <style>
        /* --- ESTILOS GERAIS --- */
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: Arial, sans-serif; position: relative; }
        #map { height: 100%; width: 100%; }
        
        /* MENUS E INTERFACE */
        .menu { position: absolute; top: 50%; left: 20px; transform: translateY(-50%); background-color: white; border-radius: 8px; box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2); z-index: 1000; display: flex; flex-direction: column; align-items: center; padding: 10px 0; max-height: 70vh; overflow-y: auto; scrollbar-width: none; -ms-overflow-style: none; transition: transform 0.3s ease, opacity 0.3s ease; }
        .menu::-webkit-scrollbar { display: none; }
        .menu.hidden { transform: translate(-200%, -50%); opacity: 0; pointer-events: none; }
        
        .menu button { position: relative; background-color: #ffffff; border: none; padding: 10px; margin: 5px 0; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2); cursor: pointer; transition: all 0.2s; flex-shrink: 0; }
        .menu button:hover { background-color: #f0f0f0; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); }
        .menu button img { width: 22px; height: 22px; }
        .menu button#btnRoutePlanner.active { background-color: #d1e3ff; box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3); }
        
        .button-legend { position: absolute; top: 50%; left: 50px; transform: translateY(-50%); background: rgba(255,255,255,0.9); border-radius: 4px; box-shadow: 0 2px 6px rgba(0,0,0,0.2); padding: 5px; font-size: 12px; white-space: nowrap; z-index: 2000; display: none; }
        
        /* BARRA DE BUSCA */
        .search-bar { position: absolute; top: 20px; left: 20px; width: 300px; background-color: white; border-radius: 8px; box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2); z-index: 1000; display: flex; padding: 10px; align-items: center; gap: 10px; }
        .search-bar input { flex: 1; border: none; outline: none; padding: 10px; font-size: 14px; border-radius: 8px; background-color: #f9f9f9; box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1); }
        .search-bar button { background-color: #4285F4; color: white; border: none; padding: 10px; border-radius: 8px; cursor: pointer; transition: background-color 0.3s; }
        .search-bar button:hover { background-color: #357ae8; }
        
        /* BOTÃO TOGGLE UI */
        .toggle-menu-btn { position: absolute; top: 20px; left: 340px; width: 40px; height: 40px; background-color: white; border-radius: 8px; box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2); z-index: 1000; display: flex; align-items: center; justify-content: center; border: none; cursor: pointer; transition: background-color 0.3s; }
        .toggle-menu-btn:hover { background-color: #f0f0f0; }
        .toggle-menu-btn img { width: 20px; height: 20px; }

        /* RESULTADOS DA BUSCA */
        .search-results { position: absolute; top: 70px; left: 20px; width: 320px; max-height: 250px; overflow-y: auto; background-color: white; border-radius: 8px; box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2); z-index: 1000; display: none; }
        .search-results ul { list-style: none; margin: 0; padding: 0; }
        .search-results li { padding: 10px; border-bottom: 1px solid #f0f0f0; display: flex; justify-content: space-between; align-items: center; }
        .search-results li:hover { background-color: #f0f0f0; }
        .search-results .result-info { flex-grow: 1; cursor: default; }
        .search-results .result-info small { color: #555; font-size: 0.8em; }
        .search-results .result-actions { display: flex; gap: 5px; flex-shrink: 0; margin-left: 10px; }
        .search-results button { background-color: #4285F4; color: white; border: none; padding: 5px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; }

        /* MENUS FLUTUANTES */
        .kmz-menu, .line-menu, .loaded-files-menu, .style-menu, .marker-group-menu, .offline-menu, .storage-menu, .tools-menu {
            position: absolute; top: 80px; left: 70px; background: #fff; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.2); z-index: 2000; padding: 10px; display: none; max-height: 400px; overflow-y: auto;
        }
        .kmz-menu, .line-menu { width: 300px; }
        .loaded-files-menu { width: 220px; }
        .style-menu { width: 200px; }
        .marker-group-menu { width: 240px; }
        
        .tools-menu { width: 280px; flex-direction: column; gap: 15px; padding: 15px; }
        .tools-menu h3 { margin: 0 0 10px 0; font-size: 16px; text-align: center; border-bottom: 1px solid #eee; padding-bottom: 5px; }
        .tool-item { display: flex; flex-direction: column; gap: 5px; margin-bottom: 10px; }
        .tool-item label { font-size: 13px; font-weight: bold; color: #333; display: flex; justify-content: space-between; }
        .tool-item input[type="range"] { width: 100%; cursor: pointer; }

        .kmz-menu ul, .line-menu ul, .loaded-files-menu ul, .style-menu ul, .marker-group-menu ul { list-style: none; margin: 0; padding: 0; }
        .kmz-menu li, .line-menu li, .style-menu li, .marker-group-menu li { padding: 8px 10px; cursor: pointer; border-bottom: 1px solid #f0f0f0; }
        .kmz-menu li:hover, .style-menu li:hover { background-color: #f0f0f0; }
        
        .loaded-files-menu li { display: flex; justify-content: space-between; align-items: center; padding: 5px 0; border-bottom: 1px solid #f0f0f0; }
        .loaded-files-menu li button { background-color: #e74c3c; color: white; border: none; padding: 3px 6px; border-radius: 4px; cursor: pointer; font-size: 10px; }

        /* Menu Offline */
        .offline-menu { width: 300px; max-height: 450px; flex-direction: column; }
        .offline-menu h3 { margin: 10px 0; font-size: 16px; text-align: center; border-top: 1px solid #eee; padding-top: 15px; }
        .offline-menu .offline-toggle-buttons { display: flex; gap: 10px; margin-bottom: 10px; }
        .offline-menu .offline-toggle-buttons button { background-color: #eee; border: 1px solid #ccc; color: #333; padding: 5px; border-radius: 5px; cursor: pointer; flex: 1; font-size: 12px; }
        .offline-menu-content { display: flex; align-items: center; justify-content: space-between; gap: 10px; padding-bottom: 10px; border-bottom: 1px solid #eee; }
        .offline-menu-label { font-weight: bold; font-size: 14px; flex-grow: 1; }
        .offline-file-list { list-style: none; margin: 0; padding: 0; overflow-y: auto; flex-grow: 1; max-height: 300px; }
        .offline-file-list li { padding: 6px 5px; font-size: 13px; border-bottom: 1px solid #f0f0f0; }
        .offline-file-list li label { cursor: pointer; display: flex; align-items: center; gap: 8px; }
        .offline-controls { margin-top: 15px; padding-top: 10px; border-top: 1px solid #eee; text-align: center; }
        .offline-controls button { background-color: #4285F4; color: #fff; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; width: 100%; }

        /* Toggle Switch */
        .switch { position: relative; display: inline-block; width: 50px; height: 24px; flex-shrink: 0; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; }
        input:checked + .slider { background-color: #4285F4; }
        input:checked + .slider:before { transform: translateX(26px); }
        .slider.round { border-radius: 24px; }
        .slider.round:before { border-radius: 50%; }

        /* Progress Bar */
        .progress-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 9999; display: flex; justify-content: center; align-items: center; color: white; }
        .progress-content { background: #333; padding: 30px; border-radius: 10px; text-align: center; width: 400px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        .progress-bar-container { width: 100%; background-color: #555; border-radius: 5px; margin: 15px 0; }
        .progress-bar { width: 0%; height: 20px; background-color: #4285F4; border-radius: 5px; transition: width 0.2s linear; }

        /* Route Panel */
        .route-panel { position: absolute; top: 20px; right: 20px; background: #fff; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.2); z-index: 2000; padding: 15px; width: 280px; max-height: 400px; display: none; flex-direction: column; }
        .route-panel h3 { margin: 0 0 10px 0; font-size: 16px; text-align: center; }
        .route-panel p { font-size: 12px; color: #555; margin: 0 0 10px 0; border-bottom: 1px solid #f0f0f0; padding-bottom: 10px; }
        .route-panel ul { list-style: decimal; margin: 0 0 10px 20px; padding: 0; max-height: 200px; overflow-y: auto; font-size: 13px; flex-grow: 1; }
        .route-panel li { display: flex; justify-content: space-between; align-items: center; padding: 4px 0; }
        .route-panel li span { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; padding-right: 10px; }
        .route-panel li .remove-wp { background-color: #e74c3c; color: white; border: none; padding: 2px 5px; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: bold; margin-left: 10px; flex-shrink: 0; }
        .route-panel-footer { margin-top: 10px; border-top: 1px solid #f0f0f0; padding-top: 10px; }
        .route-panel-buttons { display: flex; justify-content: space-between; margin-top: 10px; }
        .route-panel button { background-color: #ccc; color: #333; border: none; padding: 8px; border-radius: 5px; cursor: pointer; font-size: 13px; flex-basis: 48%; }
        .route-panel button#btnGenerateRoute { background-color: #4285F4; color: white; font-weight: bold; }

        /* Storage Menu */
        .storage-menu { width: 300px; display: none; flex-direction: column; gap: 10px; }
        .storage-menu h3 { margin: 0 0 5px 0; font-size: 16px; text-align: center; }
        .storage-menu p { font-size: 12px; color: #555; text-align: center; margin: 0 0 10px 0; border-bottom: 1px solid #f0f0f0; padding-bottom: 10px; }
        .storage-menu .storage-buttons { display: flex; flex-direction: column; gap: 10px; }
        .storage-menu .storage-buttons button { border: none; padding: 12px; border-radius: 5px; cursor: pointer; font-size: 13px; font-weight: bold; text-align: left; display: flex; flex-direction: column; transition: background-color 0.2s; }
        .storage-menu .storage-buttons button small { font-size: 11px; font-weight: normal; opacity: 0.9; margin-top: 4px; }
        .storage-menu .btn-danger { background-color: #fbebee; color: #c0392b; border: 1px solid #e74c3c; }
        .storage-menu .btn-danger:hover { background-color: #fadbd8; }
        .storage-menu .btn-warning { background-color: #fef9e7; color: #b08f00; border: 1px solid #f1c40f; }
        .storage-menu .btn-warning:hover { background-color: #fcf3cf; }
        .storage-menu .btn-danger-full { background-color: #e74c3c; color: white; text-align: center; }
        .storage-menu .btn-danger-full:hover { background-color: #c0392b; }

        .maplibregl-popup-content { padding: 10px; font-size: 13px; }
        .maplibregl-popup-close-button { padding: 4px; }
        .marker-group-menu .color-box { width: 15px; height: 15px; margin-right: 10px; border: 1px solid #ccc; }
        .line-menu li label, .marker-group-menu li label { cursor: pointer; width: 100%; display: flex; align-items: center; }

        footer { position: absolute; bottom: 5px; width: 100%; text-align: center; font-size: 10px; color: #555; z-index: 1001; }
    </style>
    <link href="https://unpkg.com/maplibre-gl/dist/maplibre-gl.css" rel="stylesheet" />
    
    <script src="https://unpkg.com/maplibre-gl/dist/maplibre-gl.js"></script>
    <script src="https://unpkg.com/@tmcw/togeojson"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-G7MC2S78V6"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-G7MC2S78V6');
    </script>
</head>
<body>
    <div id="map"></div>

    <div id="progressOverlay" class="progress-overlay" style="display: none;">
        <div class="progress-content">
            <h3>Construindo Cache Offline...</h3>
            <p>Isso pode levar alguns minutos. Por favor, não feche a aba.</p>
            <div class="progress-bar-container">
                <div id="progressBar" class="progress-bar"></div>
            </div>
            <p id="progressText">0 / 0</p>
        </div>
    </div>

    <div class="search-bar">
        <input type="text" id="searchInput" placeholder="Buscar no mapa..." />
        <button id="btnSearch">Buscar</button>
    </div>

    <button id="btnToggleUI" class="toggle-menu-btn" title="Ocultar/Exibir Menu Lateral">
        <img src="ícones/eye.svg" alt="Ver/Ocultar">
    </button>

    <div class="menu" id="mainMenu">
        <button id="btnKMZ" aria-label="Carregar arquivo KMZ ou KML">
            <img src="ícones/upload.svg" alt="Carregar KMZ/KML">
            <div class="button-legend">Carregar KMZ/KML</div>
        </button>

        <button id="btnMarkerGroups" aria-label="Filtrar por grupos de postos">
            <img src="ícones/utility-pole.svg" alt="Grupos de Postos">
            <div class="button-legend">Grupos de Postos</div>
        </button>
        <button id="btnLineGroups" aria-label="Filtrar por grupos de linhas">
            <img src="ícones/waypoints.svg" alt="Grupos de Linhas">
            <div class="button-legend">Grupos de Linhas</div>
        </button>
        <button id="btnNames" aria-label="Exibir ou ocultar os nomes dos marcadores">
            <img src="ícones/text-align-start.svg" alt="Exibir/Ocultar Nomes">
            <div class="button-legend">Exibir/Ocultar Nomes</div>
        </button>

        <button id="btnTools" aria-label="Ferramentas de Visualização">
            <img src="ícones/settings.svg" alt="Ferramentas"> <div class="button-legend">Ferramentas</div>
        </button>

        <button id="btnLocation" aria-label="Ir para minha localização atual">
            <img src="ícones/navigation.svg" alt="Minha Localização">
            <div class="button-legend">Minha Localização</div>
        </button>
        <button id="btnReset" aria-label="Resetar a visualização do mapa">
            <img src="ícones/rotate-cw.svg" alt="Resetar Visão">
            <div class="button-legend">Resetar Visão</div>
        </button>
        <button id="btnLoadedFiles" aria-label="Ver arquivos carregados atualmente">
            <img src="ícones/folder-open.svg" alt="Arquivos Carregados">
            <div class="button-legend">Arquivos Carregados</div>
        </button>
        <button id="btnStyles" aria-label="Mudar o estilo do mapa">
            <img src="ícones/palette.svg" alt="Estilos do Mapa">
            <div class="button-legend">Estilos do Mapa</div>
        </button>
        
        <button id="btnRoutePlanner" aria-label="Planejar Rota">
            <img src="ícones/route.svg" alt="Planejar Rota"> 
            <div class="button-legend">Planejar Rota</div>
        </button>
        <button id="btnOfflineMenu" aria-label="Mudar modo offline">
            <img src="ícones/wifi-off.svg" alt="Modo Offline"> 
            <div class="button-legend">Modo Offline</div>
        </button>
        <button id="btnStorageMenu" aria-label="Gerenciar Armazenamento">
            <img src="ícones/database-zap.svg" alt="Limpar Dados"> 
            <div class="button-legend">Limpar Dados</div>
        </button>

        <button id="btnSupport" aria-label="Grupo de Suporte">
            <img src="ícones/handshake.svg" alt="Suporte">
            <div class="button-legend">Suporte WhatsApp</div>
        </button>
    </div>

    <div id="searchResults" class="search-results"></div>

    <div class="kmz-menu" id="kmzMenu">
        <div class="offline-menu-content" style="padding: 5px 10px; border-bottom: 1px solid #f0f0f0; margin-bottom: 5px;">
            <span class="offline-menu-label">Modo Offline</span>
            <label class="switch">
                <input type="checkbox" id="offlineToggle">
                <span class="slider round"></span>
            </label>
        </div>
        <ul id="kmzList"></ul>
        <ul>
            <li id="selectDevice">Selecionar do dispositivo...</li>
        </ul>
    </div>

    <div class="tools-menu" id="toolsMenu" style="display: none;">
        <h3>Ferramentas de Visualização</h3>
        <div class="tool-item">
            <label>Espessura da Linha: <span id="valLineWidth">4</span>px</label>
            <input type="range" id="rngLineWidth" min="1" max="15" value="4">
        </div>
        <div class="tool-item">
            <label>Tamanho do Marcador: <span id="valMarkerSize">6</span>px</label>
            <input type="range" id="rngMarkerSize" min="2" max="20" value="6">
        </div>
        <div class="tool-item">
            <label>Tamanho do Texto: <span id="valTextSize">12</span>px</label>
            <input type="range" id="rngTextSize" min="8" max="24" value="12">
        </div>
        <div class="tool-item">
            <label>Qtd. Marcadores: <span id="valMarkerLimit">500</span></label>
            <input type="range" id="rngMarkerLimit" min="0" max="3000" value="500" step="50">
        </div>
    </div>

    <div class="line-menu" id="lineMenu">
        <div class="visibility-toggle">
            <label>
                <input type="checkbox" id="toggleAllLinesVisibility"> Exibir Todas as Linhas
            </label>
        </div>
        <div style="display:flex; gap:10px; margin-bottom:10px;">
            <button id="hideAll">Ocultar Todas</button>
            <button id="showAll">Exibir Todas</button>
        </div>
        <ul id="lineGroupsList"></ul>
    </div>
    <div class="loaded-files-menu" id="loadedFilesMenu">
        <h3>Arquivos Carregados</h3>
        <ul id="loadedFilesList"></ul>
    </div>

    <div class="style-menu" id="styleMenu">
        <ul id="styleList"></ul>
    </div>

    <div class="offline-menu" id="offlineMenu">
        <h3>Arquivos para Cache</h3>
        <div class="offline-toggle-buttons">
            <button id="btnOfflineSelectAll">Selecionar Todos</button>
            <button id="btnOfflineDeselectAll">Desselecionar Todos</button>
        </div>
        <ul id="offlineFileList" class="offline-file-list"></ul>
        <div class="offline-controls">
            <button id="btnSaveOfflineCache">Salvar no Cache</button>
        </div>
    </div>
    
    <div class="marker-group-menu" id="markerGroupMenu">
        <h3>Grupos de Postos</h3>
         <div class="visibility-toggle">
            <label>
                <input type="checkbox" id="toggleAllMarkersVisibility"> Exibir Todos os Marcadores
            </label>
         </div>
        <div style="display:flex; gap:10px; margin-bottom:10px;">
            <button id="hideAllMarkerGroups">Ocultar Todos</button>
            <button id="showAllMarkerGroups">Exibir Todos</button>
        </div>
        <ul id="markerGroupsList"></ul>
    </div>
    
    <div class="route-panel" id="routePanel">
        <h3>Planejador de Rota</h3>
        <p>A rota usará seu GPS como origem. Selecione as paradas (Máx: 10). O último ponto será o destino.</p>
        <ul id="routeList"></ul>
        <div class="route-panel-footer">
            <span id="routeCounter">Pontos: 0 / 10</span>
            <div class="route-panel-buttons">
                <button id="btnCancelRoute">Limpar</button>
                <button id="btnGenerateRoute">Gerar Rota</button>
            </div>
        </div>
    </div>

    <div class="storage-menu" id="storageMenu">
        <h3>Gerenciar Armazenamento</h3>
        <p>Use com cuidado. Isso removerá dados salvos no seu navegador para este site.</p>
        <div class="storage-buttons">
            <button id="btnResetOfflineDB" class="btn-danger">
                Limpar Cache de Mapas (Offline)
                <small>Remove todos os mapas KMZ salvos.</small>
            </button>
            <button id="btnResetLocalStorage" class="btn-warning">
                Limpar Configurações
                <small>Reseta cores, arquivos recentes (servidor e dispositivo) e modo.</small>
            </button>
            <button id="btnResetAllStorage" class="btn-danger-full">
                Resetar Tudo
                <small>Limpa cache, configurações e recarrega.</small>
            </button>
        </div>
    </div>
    <footer>
    Todos direitos reservados a Lucas Teixeira • Atualizado em 25/11/2025
    <div style="margin-top:10px; font-size:10px; color:#777; line-height:1.6;">
        <div>
            <script type='text/javascript' src='https://contador.s12.com.br/ad.js?id=WB1CDZ52wzww50W8'></script>
            <a href='https://contador.s12.com.br' target='_blank' style="text-decoration:none; opacity:0.7;">
                <img src='https://contador.s12.com.br/img-WB1CDZ52wzww50W8-57.gif' border='0' alt='contador' style="height:16px; vertical-align:middle;">
            </a>
        </div>
    </div>
</footer>
    <script>
        const DB_NAME = 'KMZOfflineDB';
        const DB_VERSION = 3; 
        const GEOJSON_STORE_NAME = 'geojson_files';
        const SPATIAL_INDEX_STORE_NAME = 'spatial_index';
        const MAX_WAYPOINTS = 10;
        let routeWaypoints = [];
        let routeMarkers = [];

        const SYNONYM_MAP = {
            'fusivel': 'fu', 'fusiveis': 'fu', 'fusível': 'fu', 'fusíveis': 'fu',
            'religador': 're', 'religadores': 're', 'chave': 'ch', 'chaves': 'ch',
            'banco': 'bc', 'bancos': 'bc'
        };

        const state = {
            isOfflineMode: false,
            isRoutePlanning: false, 
            markersVisible: true,
            namesVisible: true,
            linesVisible: true,
            userLocation: null,
            files: [],
            selectedGroups: new Map(),
            markerGroups: {
                '-FU': { color: 'red', visible: true },
                '-FA': { color: '#FFA500', visible: true },
                '-RE': { color: 'green', visible: true },
                'TR': { color: 'blue', visible: true },  
                'default': { color: '#FF5722', visible: true }
            },
            visualSettings: {
                lineWidth: 4, markerSize: 6, textSize: 12, markerLimit: 500 
            }
        };
        
        function loadSavedMarkerColors() {
            const saved = localStorage.getItem('markerGroupColors');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    Object.keys(parsed).forEach(key => {
                        if (state.markerGroups[key]) {
                            state.markerGroups[key].color = parsed[key];
                        }
                    });
                } catch (e) { console.error("Erro ao carregar cores dos marcadores:", e); }
            }
        }
        loadSavedMarkerColors();

        let spatialIndex = [];
        let allPointFeatures = [];
        let dynamicMarkerSource = null;
        let updateMarkersTimeout;

        // --- ESTILOS ESRI SEPARADOS (LIMPO vs HÍBRIDO) ---
        
        // Opção 1: Esri Limpo (Só Satélite)
        const esriSatelliteCleanStyle = {
            'version': 8,
            'sources': {
                'esri-satellite': {
                    'type': 'raster',
                    'tiles': ['https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'],
                    'tileSize': 256,
                    'attribution': '© Esri, Maxar, Earthstar Geographics',
                    'maxzoom': 19
                }
            },
            'layers': [
                { 'id': 'esri-satellite-layer', 'type': 'raster', 'source': 'esri-satellite', 'minzoom': 0, 'maxzoom': 24 }
            ],
            'glyphs': 'https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf'
        };

        // Opção 2: Esri Híbrido (Satélite + Ruas + Nomes)
        const esriSatelliteHybridStyle = {
            'version': 8,
            'sources': {
                'esri-satellite': {
                    'type': 'raster',
                    'tiles': ['https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'],
                    'tileSize': 256,
                    'attribution': '© Esri, Maxar, Earthstar Geographics',
                    'maxzoom': 19
                },
                'esri-transportation': {
                    'type': 'raster',
                    'tiles': ['https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Transportation/MapServer/tile/{z}/{y}/{x}'],
                    'tileSize': 256,
                    'maxzoom': 19
                },
                'esri-labels': {
                    'type': 'raster',
                    'tiles': ['https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}'],
                    'tileSize': 256,
                    'maxzoom': 19
                }
            },
            'layers': [
                { 'id': 'esri-satellite-layer', 'type': 'raster', 'source': 'esri-satellite', 'minzoom': 0, 'maxzoom': 24 },
                { 'id': 'esri-transportation-layer', 'type': 'raster', 'source': 'esri-transportation', 'minzoom': 0, 'maxzoom': 24 },
                { 'id': 'esri-labels-layer', 'type': 'raster', 'source': 'esri-labels', 'minzoom': 0, 'maxzoom': 24 }
            ],
            'glyphs': 'https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf'
        };

        const mapStyles = [
            { name: 'Positron', url: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json' },
            { name: 'Dark Matter', url: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json' },
            { name: 'Voyager', url: 'https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json' },
            { name: 'Esri Satélite (Limpo)', style: esriSatelliteCleanStyle }, // Nova opção
            { name: 'Esri Satélite (Com Nomes)', style: esriSatelliteHybridStyle } // Nova opção
        ];

        const colorPalette = ['#FF6347', '#4682B4', '#B0E0E6', '#FFD700', '#5F9EA0', '#F0E68C', '#F08080', '#20B2AA', '#ADD8E6', '#FFA07A', '#87CEEB', '#E6E6FA', '#FF7F50', '#6A5ACD', '#FFFACD', '#E55300', '#483D8B', '#DDA0DD', '#D4A29C', '#008080', '#87CEFA', '#C46210', '#53736F', '#98FB98', '#F4A460', '#3B83BD', '#FFB6C1', '#FF4500', '#33A1C9', '#F5DEB3'];
        
        let groupColorMap; 
        
        function loadGroupColorMap() {
            const storedMap = localStorage.getItem('groupColorMap');
            if (storedMap) {
                try {
                    const obj = JSON.parse(storedMap);
                    groupColorMap = new Map(Object.entries(obj));
                } catch (e) { groupColorMap = new Map(); }
            } else { groupColorMap = new Map(); }
        }

        function saveGroupColorMap() {
            try {
                const obj = Object.fromEntries(groupColorMap);
                localStorage.setItem('groupColorMap', JSON.stringify(obj));
            } catch (e) { console.error("Erro ao salvar mapa de cores:", e); }
        }
        
        loadGroupColorMap(); 

        const map = new maplibregl.Map({
            container: 'map',
            style: 'https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json',
            center: [-47.068847, -22.934973],
            zoom: 8,
            maxZoom: 24 
        });

        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        const kmzMenu = document.getElementById('kmzMenu');
        const kmzList = document.getElementById('kmzList');
        const lineMenu = document.getElementById('lineMenu');
        const lineGroupsList = document.getElementById('lineGroupsList');
        const loadedFilesMenu = document.getElementById('loadedFilesMenu');
        const loadedFilesList = document.getElementById('loadedFilesList');
        const btnLoadedFiles = document.getElementById('btnLoadedFiles');
        const styleMenu = document.getElementById('styleMenu');
        const markerGroupMenu = document.getElementById('markerGroupMenu');
        const markerGroupsList = document.getElementById('markerGroupsList');
        
        const btnTools = document.getElementById('btnTools');
        const toolsMenu = document.getElementById('toolsMenu');
        
        const rngLineWidth = document.getElementById('rngLineWidth');
        const valLineWidth = document.getElementById('valLineWidth');
        const rngMarkerSize = document.getElementById('rngMarkerSize');
        const valMarkerSize = document.getElementById('valMarkerSize');
        const rngTextSize = document.getElementById('rngTextSize');
        const valTextSize = document.getElementById('valTextSize');
        const rngMarkerLimit = document.getElementById('rngMarkerLimit');
        const valMarkerLimit = document.getElementById('valMarkerLimit');

        const btnRoutePlanner = document.getElementById('btnRoutePlanner');
        const routePanel = document.getElementById('routePanel');
        const routeList = document.getElementById('routeList');
        const routeCounter = document.getElementById('routeCounter');
        const btnGenerateRoute = document.getElementById('btnGenerateRoute');
        const btnCancelRoute = document.getElementById('btnCancelRoute');
        
        const offlineMenu = document.getElementById('offlineMenu');
        const offlineToggle = document.getElementById('offlineToggle');
        const offlineFileList = document.getElementById('offlineFileList'); 
        const btnSaveOfflineCache = document.getElementById('btnSaveOfflineCache'); 

        const storageMenu = document.getElementById('storageMenu');
        const btnResetOfflineDB = document.getElementById('btnResetOfflineDB');
        const btnResetLocalStorage = document.getElementById('btnResetLocalStorage');
        const btnResetAllStorage = document.getElementById('btnResetAllStorage');

        const progressOverlay = document.getElementById('progressOverlay');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');

        const btnToggleUI = document.getElementById('btnToggleUI');
        const mainMenu = document.getElementById('mainMenu');

        const toggleAllMarkersVisibilityCheckbox = document.getElementById('toggleAllMarkersVisibility');
        const toggleAllLinesVisibilityCheckbox = document.getElementById('toggleAllLinesVisibility');

        // LISTA COMPLETA DE 116 ARQUIVOS
        const predefinedFiles = [
             { name: 'AGUAS DE LINDOIA.kmz', url: './AGUAS DE LINDOIA.kmz' },
             { name: 'AGUDOS.kmz', url: './AGUDOS.kmz' },
             { name: 'ALTINOPOLIS.kmz', url: './ALTINOPOLIS.kmz' },
             { name: 'AMERICANA.kmz', url: './AMERICANA.kmz' },
             { name: 'AMPARO.kmz', url: './AMPARO.kmz' },
             { name: 'ARACATUBA.kmz', url: './ARACATUBA.kmz' },
             { name: 'ARARAQUARA.kmz', url: './ARARAQUARA.kmz' },
             { name: 'BARIRI.kmz', url: './BARIRI.kmz' },
             { name: 'BARRA BONITA.kmz', url: './BARRA BONITA.kmz' },
             { name: 'BARRETOS.kmz', url: './BARRETOS.kmz' },
             { name: 'BATATAIS.kmz', url: './BATATAIS.kmz' },
             { name: 'BAURU.kmz', url: './BAURU.kmz' },
             { name: 'BEBEDOURO.kmz', url: './BEBEDOURO.kmz' },
             { name: 'BIRIGUI.kmz', url: './BIRIGUI.kmz' },
             { name: 'BOA ESPERANCA DO SUL.kmz', url: './BOA ESPERANCA DO SUL.kmz' },
             { name: 'BOTUCATU.kmz', url: './BOTUCATU.kmz' },
             { name: 'BRAUNA.kmz', url: './BRAUNA.kmz' },
             { name: 'BROTAS.kmz', url: './BROTAS.kmz' },
             { name: 'CAFELANDIA.kmz', url: './CAFELANDIA.kmz' },
             { name: 'CAJOBI.kmz', url: './CAJOBI.kmz' },
             { name: 'CAJURU.kmz', url: './CAJURU.kmz' },
             { name: 'CAMPINAS BARAO GERALDO-1.kmz', url: './CAMPINAS BARAO GERALDO-1.kmz' },
             { name: 'CAMPINAS CAMPO GRANDE-1.kmz', url: './CAMPINAS CAMPO GRANDE-1.kmz' },
             { name: 'CAMPINAS CENTRO-1.kmz', url: './CAMPINAS CENTRO-1.kmz' },
             { name: 'CAMPINAS SOUZAS-1.kmz', url: './CAMPINAS SOUZAS-1.kmz' },
             { name: 'CAMPINAS TREVO-1.kmz', url: './CAMPINAS TREVO-1.kmz' },
             { name: 'CAPIVARI.kmz', url: './CAPIVARI.kmz' },
             { name: 'CONGONHAS.kmz', url: './CONGONHAS.kmz' },
             { name: 'COSMOPOLIS.kmz', url: './COSMOPOLIS.kmz' },
             { name: 'CRAVINHOS.kmz', url: './CRAVINHOS.kmz' },
             { name: 'DESCALVADO.kmz', url: './DESCALVADO.kmz' },
             { name: 'DOIS CORREGOS.kmz', url: './DOIS CORREGOS.kmz' },
             { name: 'DOURADO.kmz', url: './DOURADO.kmz' },
             { name: 'DUARTINA.kmz', url: './DUARTINA.kmz' },
             { name: 'ESPIRITO SANTO DO PINHAL.kmz', url: './ESPIRITO SANTO DO PINHAL.kmz' },
             { name: 'FRANCA.kmz', url: './FRANCA.kmz' },
             { name: 'GARCA.kmz', url: './GARCA.kmz' },
             { name: 'GAVIAO PEIXOTO.kmz', url: './GAVIAO PEIXOTO.kmz' },
             { name: 'GETULINA.kmz', url: './GETULINA.kmz' },
             { name: 'GUAIRA.kmz', url: './GUAIRA.kmz' },
             { name: 'GUANABARA.kmz', url: './GUANABARA.kmz' },
             { name: 'GUARARAPES.kmz', url: './GUARARAPES.kmz' },
             { name: 'GUARIBA.kmz', url: './GUARIBA.kmz' },
             { name: 'HIPODROMO.kmz', url: './HIPODROMO.kmz' },
             { name: 'HORTOLANDIA.kmz', url: './HORTOLANDIA.kmz' },
             { name: 'IACANGA.kmz', url: './IACANGA.kmz' },
             { name: 'IBIRA.kmz', url: './IBIRA.kmz' },
             { name: 'IBITINGA.kmz', url: './IBITINGA.kmz' },
             { name: 'IGARAPAVA.kmz', url: './IGARAPAVA.kmz' },
             { name: 'IPUA.kmz', url: './IPUA.kmz' },
             { name: 'ITAPIRA.kmz', url: './ITAPIRA.kmz' },
             { name: 'ITAPOLIS.kmz', url: './ITAPOLIS.kmz' },
             { name: 'ITATIBA.kmz', url: './ITATIBA.kmz' },
             { name: 'ITATINGA.kmz', url: './ITATINGA.kmz' },
             { name: 'ITUVERAVA.kmz', url: './ITUVERAVA.kmz' },
             { name: 'JABOTICABAL.kmz', url: './JABOTICABAL.kmz' },
             { name: 'JARDINOPOLIS.kmz', url: './JARDINOPOLIS.kmz' },
             { name: 'JAU.kmz', url: './JAU.kmz' },
             { name: 'JOSE BONIFACIO.kmz', url: './JOSE BONIFACIO.kmz' },
             { name: 'LENCOIS PAULISTA.kmz', url: './LENCOIS PAULISTA.kmz' },
             { name: 'LINS.kmz', url: './LINS.kmz' },
             { name: 'MARILIA.kmz', url: './MARILIA.kmz' },
             { name: 'MATAO.kmz', url: './MATAO.kmz' },
             { name: 'METROPOLITANA.kmz', url: './METROPOLITANA.kmz' },
             { name: 'MIGUELOPOLIS.kmz', url: './MIGUELOPOLIS.kmz' },
             { name: 'MIRASSOL.kmz', url: './MIRASSOL.kmz' },
             { name: 'MONTE ALTO.kmz', url: './MONTE ALTO.kmz' },
             { name: 'MONTE APRAZIVEL.kmz', url: './MONTE APRAZIVEL.kmz' },
             { name: 'MONTE MOR.kmz', url: './MONTE MOR.kmz' },
             { name: 'MORRO AGUDO.kmz', url: './MORRO AGUDO.kmz' },
             { name: 'MORRO DO CIPO.kmz', url: './MORRO DO CIPO.kmz' },
             { name: 'NOVA GRANADA.kmz', url: './NOVA GRANADA.kmz' },
             { name: 'OCAUCU.kmz', url: './OCAUCU.kmz' },
             { name: 'OLIMPIA.kmz', url: './OLIMPIA.kmz' },
             { name: 'ORLANDIA.kmz', url: './ORLANDIA.kmz' },
             { name: 'PARAISO.kmz', url: './PARAISO.kmz' },
             { name: 'PARDINHO.kmz', url: './PARDINHO.kmz' },
             { name: 'PAULINIA.kmz', url: './PAULINIA.kmz' },
             { name: 'PEDERNEIRAS.kmz', url: './PEDERNEIRAS.kmz' },
             { name: 'PEDREGULHO.kmz', url: './PEDREGULHO.kmz' },
             { name: 'PENAPOLIS.kmz', url: './PENAPOLIS.kmz' },
             { name: 'PIACATU.kmz', url: './PIACATU.kmz' },
             { name: 'PIRACICABA SANTA CECILIA.kmz', url: './PIRACICABA SANTA CECILIA.kmz' },
             { name: 'PIRACICABA SANTA TEREZINHA.kmz', url: './PIRACICABA SANTA TEREZINHA.kmz' },
             { name: 'PIRACICABA.kmz', url: './PIRACICABA.kmz' },
             { name: 'PIRAJUI - EA.kmz', url: './PIRAJUI - EA.kmz' },
             { name: 'PIRANGI.kmz', url: './PIRANGI.kmz' },
             { name: 'PITANGUEIRAS.kmz', url: './PITANGUEIRAS.kmz' },
             { name: 'POMPEIA.kmz', url: './POMPEIA.kmz' },
             { name: 'PRESIDENTE ALVES.kmz', url: './PRESIDENTE ALVES.kmz' },
             { name: 'PROMISSAO.kmz', url: './PROMISSAO.kmz' },
             { name: 'RESTINGA.kmz', url: './RESTINGA.kmz' },
             { name: 'RIBEIRAO PRETO NORTE.kmz', url: './RIBEIRAO PRETO NORTE.kmz' },
             { name: 'RIBEIRAO PRETO SUL.kmz', url: './RIBEIRAO PRETO SUL.kmz' },
             { name: 'RINCAO.kmz', url: './RINCAO.kmz' },
             { name: 'SANTA ADELIA.kmz', url: './SANTA ADELIA.kmz' },
             { name: 'SANTA BARBARA DOESTE.kmz', url: './SANTA BARBARA DOESTE.kmz' },
             { name: 'SANTA ROSA DE VITERBO.kmz', url: './SANTA ROSA DE VITERBO.kmz' },
             { name: 'SANTO ANTONIO ARACANGUA.kmz', url: './SANTO ANTONIO ARACANGUA.kmz' },
             { name: 'SAO CARLOS.kmz', url: './SAO CARLOS.kmz' },
             { name: 'SAO JOAQUIM DA BARRA.kmz', url: './SAO JOAQUIM DA BARRA.kmz' },
             { name: 'SAO JOSE RIO PRETO.kmz', url: './SAO JOSE RIO PRETO.kmz' },
             { name: 'SAO MANUEL.kmz', url: './SAO MANUEL.kmz' },
             { name: 'SAO PEDRO.kmz', url: './SAO PEDRO.kmz' },
             { name: 'SAO SIMAO.kmz', url: './SAO SIMAO.kmz' },
             { name: 'SERRA NEGRA.kmz', url: './SERRA NEGRA.kmz' },
             { name: 'SERRANA.kmz', url: './SERRANA.kmz' },
             { name: 'SERTAOZINHO.kmz', url: './SERTAOZINHO.kmz' },
             { name: 'SOCORRO.kmz', url: './SOCORRO.kmz' },
             { name: 'SUMARE.kmz', url: './SUMARE.kmz' },
             { name: 'TANABI.kmz', url: './TANABI.kmz' },
             { name: 'TAQUARITINGA.kmz', url: './TAQUARITINGA.kmz' },
             { name: 'UIRAPURU.kmz', url: './UIRAPURU.kmz' },
             { name: 'VALINHOS.kmz', url: './VALINHOS.kmz' },
             { name: 'VALPARAISO.kmz', url: './VALPARAISO.kmz' },
             { name: 'VIRADOURO.kmz', url: './VIRADOURO.kmz' }
        ];

        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = event => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(GEOJSON_STORE_NAME)) {
                        db.createObjectStore(GEOJSON_STORE_NAME, { keyPath: 'name' });
                    }
                    if (!db.objectStoreNames.contains(SPATIAL_INDEX_STORE_NAME)) {
                        db.createObjectStore(SPATIAL_INDEX_STORE_NAME, { keyPath: 'name' });
                    }
                };
                request.onsuccess = event => resolve(event.target.result);
                request.onerror = event => reject(event.target.error);
            });
        }

        async function saveDataToDB(storeName, data) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(data);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        async function getDataFromDB(storeName, key) {
             const db = await openDB();
                 return new Promise((resolve, reject) => {
                     const transaction = db.transaction([storeName], 'readonly');
                     const store = transaction.objectStore(storeName);
                     const request = key ? store.get(key) : store.getAll();
                     request.onsuccess = () => resolve(request.result);
                     request.onerror = () => reject(request.error);
                 });
             }

        async function countDBItems(storeName) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.count();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        function calculateBounds(geojson) {
            let minLng = 180, minLat = 90, maxLng = -180, maxLat = -90;
            function extractCoords(coords) {
                if (typeof coords[0] === 'number' && typeof coords[1] === 'number') {
                    const [lng, lat] = coords;
                    if (lng < minLng) minLng = lng;
                    if (lat < minLat) minLat = lat;
                    if (lng > maxLng) maxLng = lng;
                    if (lat > maxLat) maxLat = lat;
                } else if (Array.isArray(coords)) {
                    coords.forEach(extractCoords);
                }
            }
            geojson.features.forEach(feature => {
                if (feature.geometry && feature.geometry.coordinates) {
                    extractCoords(feature.geometry.coordinates);
                }
            });
            return (minLng > 179) ? null : [minLng, minLat, maxLng, maxLat];
        }

        function boundsIntersect(fileBoundsArray, mapBounds) {
            if (!fileBoundsArray) return false;
            const mapWest = mapBounds.getWest();
            const mapEast = mapBounds.getEast();
            const mapSouth = mapBounds.getSouth();
            const mapNorth = mapBounds.getNorth();
            const fileWest = fileBoundsArray[0];
            const fileSouth = fileBoundsArray[1];
            const fileEast = fileBoundsArray[2];
            const fileNorth = fileBoundsArray[3];
            const noOverlap = fileEast < mapWest || fileWest > mapEast || fileNorth < mapSouth || fileSouth > mapNorth;
            return !noOverlap;
        }

        function getBoundsCenter(bounds) {
            if (!bounds) return null;
            const centerLng = (bounds[0] + bounds[2]) / 2;
            const centerLat = (bounds[1] + bounds[3]) / 2;
            return new maplibregl.LngLat(centerLng, centerLat);
        }

        let updateTimeout;
        async function updateVisibleLayers() {
            clearTimeout(updateTimeout);
            updateTimeout = setTimeout(async () => {
                if (!state.isOfflineMode) return;

                const mapBounds = map.getBounds();
                const mapCenter = map.getCenter();
                const loadedFileNames = new Set(state.files.map(f => f.name));

                const visibleCandidates = [];
                for (const file of spatialIndex) {
                    if (boundsIntersect(file.bounds, mapBounds)) {
                        const boundsCenter = getBoundsCenter(file.bounds);
                        if (boundsCenter) {
                            const distance = mapCenter.distanceTo(boundsCenter);
                            visibleCandidates.push({ name: file.name, distance: distance });
                        }
                    }
                }

                let filesToDisplay = [];
                if (visibleCandidates.length > 4) {
                    visibleCandidates.sort((a, b) => a.distance - b.distance);
                    filesToDisplay = visibleCandidates.slice(0, 4);
                } else {
                    filesToDisplay = visibleCandidates;
                }

                const requiredFiles = new Set(filesToDisplay.map(f => f.name));
                
                for (const loadedFile of loadedFileNames) {
                    if (!requiredFiles.has(loadedFile)) {
                        removeFileFromMap(loadedFile);
                    }
                }

                for (const requiredFile of requiredFiles) {
                    if (!loadedFileNames.has(requiredFile)) {
                        const data = await getDataFromDB(GEOJSON_STORE_NAME, requiredFile);
                        if (data) {
                            addDataToMap(data.geojson, data.name);
                        }
                    }
                }
            }, 300);
        }

        function clearMap() {
            const filesToRemove = [...state.files];
            filesToRemove.forEach(file => removeFileFromMap(file.name));
            state.files = [];
            loadedFilesList.innerHTML = '';
            allPointFeatures = [];
            updateVisibleMarkers();
        }

        async function handleModeChange(isOffline) {
            clearMap();
            state.isOfflineMode = isOffline;
            
            const kmzListUl = document.getElementById('kmzList');
            const selectDeviceLi = document.getElementById('selectDevice');
            
            if (isOffline) {
                kmzListUl.style.pointerEvents = 'none';
                kmzListUl.style.opacity = '0.5';
                selectDeviceLi.style.display = 'none';
            } else {
                kmzListUl.style.pointerEvents = 'auto';
                kmzListUl.style.opacity = '1';
                selectDeviceLi.style.display = 'block';
            }

            if (isOffline) {
                console.log("Ativando modo offline dinâmico...");
                map.on('moveend', updateVisibleLayers);
                
                spatialIndex = await getDataFromDB(SPATIAL_INDEX_STORE_NAME);
                updateVisibleLayers();
                
            } else {
                console.log("Desativando modo offline...");
                map.off('moveend', updateVisibleLayers);
                spatialIndex = [];
            }
        }

        function updateVisibleMarkers() {
            clearTimeout(updateMarkersTimeout);
            updateMarkersTimeout = setTimeout(() => {
                if (!dynamicMarkerSource) return;

                const mapCenter = map.getCenter();
                const visibleGroups = Object.keys(state.markerGroups).filter(g => state.markerGroups[g].visible);

                const filteredFeatures = allPointFeatures.filter(feature => visibleGroups.includes(feature.properties.group));

                const sortedFeatures = filteredFeatures.map(feature => {
                    if (!feature || !feature.geometry || !Array.isArray(feature.geometry.coordinates) || feature.geometry.coordinates.length < 2) {
                        return { ...feature, properties: { ...feature.properties, distance: Infinity } };
                    }
                    const distance = computeDistance([mapCenter.lng, mapCenter.lat], feature.geometry.coordinates);
                    return { ...feature, properties: { ...feature.properties, distance: distance } };
                }).sort((a, b) => a.properties.distance - b.properties.distance);

                const limit = parseInt(state.visualSettings.markerLimit);
                const limitedFeatures = sortedFeatures.slice(0, limit);

                const geojson = {
                    type: 'FeatureCollection',
                    features: limitedFeatures
                };
                dynamicMarkerSource.setData(geojson);
            }, 150);
        }

        async function buildOfflineDatabase(filesToCache) {
            if (!filesToCache || filesToCache.length === 0) {
                alert("Nenhum arquivo selecionado para salvar no cache.");
                return;
            }
            
            progressOverlay.style.display = 'flex';
            progressBar.style.width = `0%`;
            progressText.textContent = `0 / ${filesToCache.length}`;
            
            let count = 0;
            for (const file of filesToCache) {
                try {
                    const geojson = await parseKMZFromUrl(file.url);
                    await saveDataToDB(GEOJSON_STORE_NAME, { name: file.name, geojson });
                    const bounds = calculateBounds(geojson);
                    if (bounds) {
                        await saveDataToDB(SPATIAL_INDEX_STORE_NAME, { name: file.name, bounds });
                    }
                    count++;
                    const percentage = (count / filesToCache.length) * 100;
                    progressBar.style.width = `${percentage}%`;
                    progressText.textContent = `${count} / ${filesToCache.length}`;
                } catch (error) {
                    console.error(`Erro ao processar ${file.name}:`, error);
                }
            }
            progressOverlay.style.display = 'none';
            alert('Cache offline construído com sucesso para os arquivos selecionados!');
        }

        async function parseKMZFromUrl(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Falha ao buscar ${url}`);
                const arrayBuffer = await response.arrayBuffer();
                return await parseKMZ(arrayBuffer);
            } catch (error) {
                throw error;
            }
        }

        async function cacheKMZData(fileName, geojson) {
            try {
                await saveDataToDB(GEOJSON_STORE_NAME, { name: fileName, geojson: geojson });
                
                const bounds = calculateBounds(geojson);
                if (bounds) {
                    await saveDataToDB(SPATIAL_INDEX_STORE_NAME, { name: fileName, bounds: bounds });
                }
            } catch (e) { console.error(e); }
       }

        async function getKMZFromCache(fileName) {
            const data = await getDataFromDB(GEOJSON_STORE_NAME, fileName);
            if (data && data.geojson) return data.geojson;
            return null;
       }

        map.on('click', (e) => { 
            if (!e.originalEvent.target.closest('.menu, .search-bar, .search-results, .kmz-menu, .line-menu, .loaded-files-menu, .style-menu, .marker-group-menu, .offline-menu, .maplibregl-popup, .route-panel, .storage-menu, .toggle-menu-btn, .tools-menu')) {
                kmzMenu.style.display = 'none';
                lineMenu.style.display = 'none';
                loadedFilesMenu.style.display = 'none';
                styleMenu.style.display = 'none';
                searchResults.style.display = 'none';
                markerGroupMenu.style.display = 'none';
                offlineMenu.style.display = 'none'; 
                storageMenu.style.display = 'none';
                toolsMenu.style.display = 'none'; 
            }
        });

        function updateRecentFiles(fileName) {
            let recentFiles = JSON.parse(localStorage.getItem('recentFiles') || '[]');
            recentFiles = recentFiles.filter(f => f !== fileName);
            recentFiles.unshift(fileName);
            recentFiles = recentFiles.slice(0, 5);
            localStorage.setItem('recentFiles', JSON.stringify(recentFiles));
        }

        function updateRecentExternalFiles(fileName) {
            let recentFiles = JSON.parse(localStorage.getItem('recentExternalFiles') || '[]');
            recentFiles = recentFiles.filter(f => f !== fileName);
            recentFiles.unshift(fileName);
            recentFiles = recentFiles.slice(0, 5);
            localStorage.setItem('recentExternalFiles', JSON.stringify(recentFiles));
        }

        function displayFileList() {
            kmzList.innerHTML = '';
            const recentFiles = JSON.parse(localStorage.getItem('recentFiles') || '[]');
            const recentFileSet = new Set(recentFiles);

            const recent = predefinedFiles.filter(file => recentFileSet.has(file.name));
            const others = predefinedFiles.filter(file => !recentFileSet.has(file.name));

            const sortedRecent = recent.sort((a, b) => recentFiles.indexOf(a.name) - recentFiles.indexOf(b.name));
            const sortedOthers = others.sort((a, b) => a.name.localeCompare(b.name));
            const sortedFiles = [...sortedRecent, ...sortedOthers];

            sortedFiles.forEach((file) => {
                const li = document.createElement('li');
                li.textContent = file.name;
                li.addEventListener('click', (e) => {
                    e.stopPropagation();
                    loadKMZFromURL(file.url, file.name);
                    localStorage.setItem('lastSelectedFile', file.name);
                    updateRecentFiles(file.name);
                    displayFileList();
                    kmzMenu.style.display = 'none';
                });
                kmzList.appendChild(li);
            });
        }
        
        function populateOfflineFileList() {
            if (!offlineFileList) return;
            offlineFileList.innerHTML = '';
            const sortedFiles = [...predefinedFiles].sort((a, b) => a.name.localeCompare(b.name));

            sortedFiles.forEach((file) => {
                const li = document.createElement('li');
                const label = document.createElement('label');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.name = 'offlineFile';
                checkbox.value = file.name;
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(file.name));
                li.appendChild(label);
                offlineFileList.appendChild(li);
            });
        }

        displayFileList();
        updateMarkerGroupMenu();
        populateOfflineFileList();

        map.on('load', () => {
            const legends = document.querySelectorAll('.button-legend');
            legends.forEach(legend => { legend.style.display = 'block'; });
            setTimeout(() => { legends.forEach(legend => { legend.style.display = 'none'; }); }, 5000);

            map.addSource('dynamic-markers', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });
            dynamicMarkerSource = map.getSource('dynamic-markers');

            map.addLayer({
                id: 'dynamic-marker-circles',
                type: 'circle',
                source: 'dynamic-markers',
                paint: {
                    'circle-radius': parseInt(state.visualSettings.markerSize), 
                    'circle-color': ['get', 'color'],
                    'circle-stroke-width': 2,
                    'circle-stroke-color': '#FFFFFF'
                }
            });

            map.addLayer({
                id: 'dynamic-marker-labels',
                type: 'symbol',
                source: 'dynamic-markers',
                layout: {
                    'text-field': ['coalesce', ['get', 'name'], ['get', 'Alimentador']],
                    'text-font': ['Open Sans Bold'], 
                    'text-size': parseInt(state.visualSettings.textSize), 
                    'text-offset': [0, 1.5],
                    'visibility': state.namesVisible ? 'visible' : 'none'
                },
                paint: {
                    'text-color': '#000000',
                    'text-halo-color': '#FFFFFF',
                    'text-halo-width': 1
                }
            });

            map.on('moveend', updateVisibleMarkers);
            toggleAllMarkersVisibilityCheckbox.checked = state.markersVisible;
            toggleAllLinesVisibilityCheckbox.checked = state.linesVisible;

            const savedMode = localStorage.getItem('offlineMode') === 'true';
            offlineToggle.checked = savedMode;
            setTimeout(() => handleModeChange(savedMode), 100); 

            if (!savedMode) {
                const recentFiles = JSON.parse(localStorage.getItem('recentFiles') || '[]');
                const filesToLoad = recentFiles.slice(0, 2); 
                
                if (filesToLoad.length > 0) {
                    filesToLoad.forEach(fileName => {
                        const file = predefinedFiles.find(f => f.name === fileName);
                        if (file) loadKMZFromURL(file.url, file.name);
                    });
                }

                const recentExternalFiles = JSON.parse(localStorage.getItem('recentExternalFiles') || '[]');
                if (recentExternalFiles.length > 0) {
                    (async () => {
                        for (const fileName of recentExternalFiles) {
                            const cachedData = await getKMZFromCache(fileName); 
                            if (cachedData) addDataToMap(cachedData, fileName);
                        }
                    })();
                }
            }

            map.on('click', 'dynamic-marker-circles', (e) => {
                e.originalEvent.stopPropagation();
                if (!e.features || e.features.length === 0) return;
                const feature = e.features[0];
                const coordinates = feature.geometry.coordinates.slice();
                const properties = feature.properties;
                const displayName = properties.name || properties.Alimentador || 'Sem nome';
                const featureId = feature.id || (properties.name + coordinates.join('')).replace(/[^a-z0-9]/gi, '');

                while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
                    coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
                }

                let popupHTML;
                if (state.isRoutePlanning) {
                    popupHTML = `<div><strong>${displayName}</strong><br><button id="popup-add-route-btn-${featureId}" style="margin-top: 5px; padding: 3px 8px; font-size: 11px; cursor: pointer; background-color: #f7b731; color: black; border: none; border-radius: 3px;">Adicionar à Rota</button></div>`;
                } else {
                    popupHTML = `<div><strong>${displayName}</strong><br><button id="popup-directions-btn-${featureId}" style="margin-top: 5px; padding: 3px 8px; font-size: 11px; cursor: pointer;">Obter Rota (Google Maps)</button></div>`;
                }

                const popup = new maplibregl.Popup({ closeOnClick: true, offset: 15 }).setLngLat(coordinates).setHTML(popupHTML).addTo(map);
                const popupElement = popup.getElement();

                if (state.isRoutePlanning) {
                    const addRouteBtn = popupElement.querySelector(`#popup-add-route-btn-${featureId}`);
                    if (addRouteBtn) {
                        addRouteBtn.addEventListener('click', () => { addWaypointToRoute(feature); popup.remove(); });
                    }
                } else {
                    const directionsBtn = popupElement.querySelector(`#popup-directions-btn-${featureId}`);
                    if (directionsBtn) {
                        directionsBtn.addEventListener('click', () => {
                            const lat = coordinates[1];
                            const lng = coordinates[0];
                            const url = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&travelmode=driving`;
                            window.open(url, '_blank');
                        });
                    }
                }
            });

            map.on('mouseenter', 'dynamic-marker-circles', () => { map.getCanvas().style.cursor = 'pointer'; });
            map.on('mouseleave', 'dynamic-marker-circles', () => { if (!state.isRoutePlanning) map.getCanvas().style.cursor = ''; });
        }); 

        offlineToggle.addEventListener('change', (event) => {
            const isChecked = event.target.checked;
            if (typeof gtag === 'function') gtag('event', 'offline_toggle', { 'status': isChecked ? 'enabled' : 'disabled' });
            localStorage.setItem('offlineMode', isChecked);
            handleModeChange(isChecked);
        });

        btnSaveOfflineCache.addEventListener('click', (e) => {
            e.stopPropagation(); 
            const checkedBoxes = offlineFileList.querySelectorAll('input[type="checkbox"]:checked');
            const filesToCache = [];
            checkedBoxes.forEach(box => {
                const fileName = box.value;
                const file = predefinedFiles.find(f => f.name === fileName);
                if (file) filesToCache.push(file);
            });
            if (filesToCache.length > 0) buildOfflineDatabase(filesToCache);
            else alert("Nenhum arquivo selecionado.");
        });

        document.getElementById('btnOfflineSelectAll').addEventListener('click', (e) => {
            e.stopPropagation(); 
            offlineFileList.querySelectorAll('input[type="checkbox"]').forEach(box => box.checked = true);
        });

        document.getElementById('btnOfflineDeselectAll').addEventListener('click', (e) => {
            e.stopPropagation(); 
            offlineFileList.querySelectorAll('input[type="checkbox"]').forEach(box => box.checked = false);
        });

        document.getElementById('btnKMZ').addEventListener('click', (e) => { e.stopPropagation(); toggleVisibility(kmzMenu); });
        document.getElementById('btnNames').addEventListener('click', () => toggleNames());
        document.getElementById('btnReset').addEventListener('click', resetView);
        document.getElementById('btnLocation').addEventListener('click', goToCurrentLocation);
        document.getElementById('btnLineGroups').addEventListener('click', (e) => {
            e.stopPropagation();
            if (state.selectedGroups.size === 0) alert('Não há grupos de linhas para filtrar.');
            else toggleVisibility(lineMenu);
        });
        btnLoadedFiles.addEventListener('click', (e) => { e.stopPropagation(); toggleVisibility(loadedFilesMenu); });
        document.getElementById('btnSearch').addEventListener('click', searchFeatures);
        document.getElementById('selectDevice').addEventListener('click', (e) => { e.stopPropagation(); selectFromDevice(); });
        document.getElementById('hideAll').addEventListener('click', hideAllGroups);
        document.getElementById('showAll').addEventListener('click', showAllGroups);
        document.getElementById('btnStyles').addEventListener('click', (e) => { e.stopPropagation(); displayStyleList(); toggleVisibility(styleMenu); });
        document.getElementById('btnMarkerGroups').addEventListener('click', (e) => { e.stopPropagation(); toggleVisibility(markerGroupMenu); });
        document.getElementById('btnOfflineMenu').addEventListener('click', (e) => { e.stopPropagation(); toggleVisibility(offlineMenu); });
        btnRoutePlanner.addEventListener('click', (e) => { e.stopPropagation(); toggleRoutePlanning(); });
        btnGenerateRoute.addEventListener('click', generateGoogleMapsUrl);
        btnCancelRoute.addEventListener('click', cancelRoutePlanning);
        document.getElementById('hideAllMarkerGroups').addEventListener('click', () => toggleAllMarkerGroups(false));
        document.getElementById('showAllMarkerGroups').addEventListener('click', () => toggleAllMarkerGroups(true));
        toggleAllMarkersVisibilityCheckbox.addEventListener('change', (e) => { toggleMarkers(e.target.checked); });
        toggleAllLinesVisibilityCheckbox.addEventListener('change', (e) => { toggleLines(e.target.checked); });
        document.getElementById('btnStorageMenu').addEventListener('click', (e) => { e.stopPropagation(); toggleVisibility(storageMenu); });
        btnToggleUI.addEventListener('click', (e) => { e.stopPropagation(); mainMenu.classList.toggle('hidden'); });
        btnTools.addEventListener('click', (e) => { e.stopPropagation(); toggleVisibility(toolsMenu); });

        function updateMapVisuals() {
            state.files.forEach(file => {
                if (file.hasLines) {
                    const lineLayerId = `lines-${file.sourceId}`;
                    if (map.getLayer(lineLayerId)) map.setPaintProperty(lineLayerId, 'line-width', parseInt(state.visualSettings.lineWidth));
                }
            });
            if (map.getLayer('dynamic-marker-circles')) map.setPaintProperty('dynamic-marker-circles', 'circle-radius', parseInt(state.visualSettings.markerSize));
            if (map.getLayer('dynamic-marker-labels')) map.setLayoutProperty('dynamic-marker-labels', 'text-size', parseInt(state.visualSettings.textSize));
        }

        rngLineWidth.addEventListener('input', (e) => {
            valLineWidth.textContent = e.target.value;
            state.visualSettings.lineWidth = e.target.value;
            updateMapVisuals();
        });
        rngMarkerSize.addEventListener('input', (e) => {
            valMarkerSize.textContent = e.target.value;
            state.visualSettings.markerSize = e.target.value;
            updateMapVisuals();
        });
        rngTextSize.addEventListener('input', (e) => {
            valTextSize.textContent = e.target.value;
            state.visualSettings.textSize = e.target.value;
            updateMapVisuals();
        });
        rngMarkerLimit.addEventListener('input', (e) => {
            valMarkerLimit.textContent = e.target.value;
            state.visualSettings.markerLimit = e.target.value;
            updateVisibleMarkers(); 
        });

        btnResetOfflineDB.addEventListener('click', (e) => {
            e.stopPropagation();
            if (confirm('TEM CERTEZA? Isso limpará o cache offline.')) {
                const deleteRequest = indexedDB.deleteDatabase(DB_NAME);
                deleteRequest.onsuccess = () => { alert('Cache limpo.'); location.reload(); };
            }
        });

        btnResetLocalStorage.addEventListener('click', (e) => {
            e.stopPropagation();
            if (confirm('TEM CERTEZA? Isso limpará configurações.')) { localStorage.clear(); alert('Resetado.'); location.reload(); }
        });

        btnResetAllStorage.addEventListener('click', (e) => {
            e.stopPropagation();
            if (confirm('TEM CERTEZA ABSOLUTA? Reset Total.')) {
                localStorage.clear();
                indexedDB.deleteDatabase(DB_NAME).onsuccess = () => { alert('Tudo limpo.'); location.reload(); };
            }
        });

        document.getElementById('btnSupport').addEventListener('click', (e) => { e.stopPropagation(); window.open('https://chat.whatsapp.com/KmBQvO3u5Pm53cV3XWz2dX', '_blank'); });

        function toggleVisibility(element) {
            [kmzMenu, lineMenu, loadedFilesMenu, styleMenu, markerGroupMenu, offlineMenu, routePanel, storageMenu, toolsMenu].forEach(menu => {
                if (menu !== element) {
                    if (menu === routePanel && state.isRoutePlanning) {} else { menu.style.display = 'none'; }
                }
            });
            if ([routePanel, offlineMenu, storageMenu, toolsMenu].includes(element)) {
                if (element === routePanel) element.style.display = state.isRoutePlanning ? 'flex' : 'none';
                else element.style.display = (element.style.display === 'flex') ? 'none' : 'flex';
            } else {
                 element.style.display = (element.style.display === 'block') ? 'none' : 'block';
            }
        }

        function selectFromDevice() {
            if (state.isOfflineMode) return;
            kmzMenu.style.display = 'none';
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.kml,.kmz';
            input.onchange = handleFile;
            input.click();
        }

        async function loadKMZFromURL(url, fileName) {
            if (typeof gtag === 'function') gtag('event', 'map_load', { 'file_name': fileName, 'load_source': 'server', 'is_offline_mode': state.isOfflineMode });
            if (state.isOfflineMode) return;
            try {
                const cachedData = await getKMZFromCache(fileName); 
                if (cachedData) { addDataToMap(cachedData, fileName); return; }
                const geojson = await parseKMZFromUrl(url);
                if(geojson) addDataToMap(geojson, fileName);
            } catch (error) {
                // TRATAMENTO DE ERRO AMIGÁVEL (SEM ALERTAS INTRUSIVOS DE FETCH)
                // Apenas ignora se falhar o fetch automático, o usuário pode usar o botão "Selecionar do dispositivo"
                console.log(`Não foi possível carregar "${fileName}" automaticamente via URL.`);
            }
        }

        function handleFile(event) {
            if (state.isOfflineMode) return;
            const file = event.target.files[0];
            if (!file) return;
            if (typeof gtag === 'function') gtag('event', 'map_load', { 'file_name': file.name, 'load_source': 'device', 'is_offline_mode': state.isOfflineMode });

            const reader = new FileReader();
            reader.onload = async () => {
                try {
                    const data = file.name.endsWith('.kmz') ? await parseKMZ(reader.result) : toGeoJSON.kml(new DOMParser().parseFromString(reader.result, 'text/xml'));
                    addDataToMap(data, file.name);
                    updateRecentExternalFiles(file.name); 
                } catch (error) { alert('Erro ao processar arquivo.'); }
            };
            if (file.name.endsWith('.kmz')) reader.readAsArrayBuffer(file);
            else reader.readAsText(file);
        }

        async function parseKMZ(data) {
            const zip = await JSZip.loadAsync(data);
            const kmlFile = zip.file(/\.kml$/i)[0];
            if (!kmlFile) throw new Error('KML não encontrado no KMZ.');
            const kmlContent = await kmlFile.async('string');
            return toGeoJSON.kml(new DOMParser().parseFromString(kmlContent, 'text/xml'));
        }

        function applyColorUpdate(groupName, sourceId, newColor) {
            groupColorMap.set(groupName, newColor);
            saveGroupColorMap();
            const file = state.files.find(f => f.sourceId === sourceId);
            if (!file) return;

            let featuresUpdated = false;
            file.lineFeatures.features.forEach(feature => {
                if (feature.properties && feature.properties[file.groupingProperty] === groupName) {
                    feature.properties.color = newColor;
                    featuresUpdated = true;
                }
            });

            if (featuresUpdated) {
                const source = map.getSource(file.sourceId + '-lines');
                if (source) source.setData(file.lineFeatures);
            }
            const menuInput = document.querySelector(`input[type="color"][data-group-name="${groupName}"][data-source-id="${sourceId}"]`);
            if (menuInput) menuInput.value = newColor;
        }

        function handleColorChange(event) {
            applyColorUpdate(event.target.dataset.groupName, event.target.dataset.sourceId, event.target.value);
        }

        function changeMarkerGroupColor(groupKey, newColor) {
            if (state.markerGroups[groupKey]) state.markerGroups[groupKey].color = newColor;
            const colorsToSave = {};
            Object.keys(state.markerGroups).forEach(key => colorsToSave[key] = state.markerGroups[key].color);
            localStorage.setItem('markerGroupColors', JSON.stringify(colorsToSave));
            allPointFeatures.forEach(feature => {
                if (feature.properties.group === groupKey) feature.properties.color = newColor;
            });
            updateVisibleMarkers();
            const labelText = document.querySelector(`label[data-group-label="${groupKey}"] span`);
            if(labelText) labelText.style.color = newColor;
        }

        function addDataToMap(geojson, fileName) {
            const sanitizedFileName = fileName.replace(/\s+/g, '_').replace(/[^\w\-]/g, '');
            const sourceId = `source-${sanitizedFileName}`;
            const lineLayerId = `lines-${sourceId}`;

            if (state.files.find(file => file.name === fileName)) return;

            const pointFeaturesToAdd = [];
            const lineFeaturesArray = [];

            function extractGeometries(feature) {
                const geometries = [];
                if (feature.geometry && feature.geometry.type === 'GeometryCollection') {
                    feature.geometry.geometries.forEach(geom => geometries.push({ ...feature, geometry: geom }));
                } else if (feature.geometry) {
                    geometries.push(feature);
                }
                return geometries;
            }

            let groupingProperty = null;
            const exampleFeature = geojson.features.find(f => f.properties && (f.properties.Alimentador || f.properties.name));
            if (exampleFeature) groupingProperty = exampleFeature.properties.Alimentador ? 'Alimentador' : 'name';

            geojson.features.forEach(feature => {
                const features = extractGeometries(feature);
                features.forEach(f => {
                    if (f.geometry.type === 'Point') {
                        const name = (f.properties.name || '').toUpperCase();
                        
                        let groupKey = 'default';
                        if (name.endsWith('-FU')) groupKey = '-FU';
                        else if (name.endsWith('-FA')) groupKey = '-FA';
                        else if (name.endsWith('-RE')) groupKey = '-RE';
                        else if (name.endsWith('KVA') || name.includes('TR')) groupKey = 'TR'; 

                        f.properties.group = groupKey;
                        f.properties.color = state.markerGroups[groupKey] ? state.markerGroups[groupKey].color : state.markerGroups['default'].color;
                        f.properties.fileName = fileName;
                        pointFeaturesToAdd.push(f);
                    } else if (['LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'].includes(f.geometry.type)) {
                        f.properties = f.properties || {};
                        const groupName = f.properties[groupingProperty];
                        let color = groupColorMap.get(groupName);
                        if (!color) {
                            color = colorPalette[groupColorMap.size % colorPalette.length];
                            groupColorMap.set(groupName, color);
                            saveGroupColorMap(); 
                        }
                        f.properties.color = color;
                        lineFeaturesArray.push(f);
                    }
                });
            });

            allPointFeatures.push(...pointFeaturesToAdd);

            const lineFeatures = { type: 'FeatureCollection', features: lineFeaturesArray };
            const groupsSet = new Set();
            if (lineFeatures.features.length > 0 && groupingProperty) {
                lineFeatures.features.forEach(f => {
                    if (f.properties && f.properties[groupingProperty]) groupsSet.add(f.properties[groupingProperty]);
                });
            }
            if (groupingProperty && groupsSet.size > 0) state.selectedGroups.set(sourceId, new Set(groupsSet));

            state.files.push({
                name: fileName,
                sourceId: sourceId,
                hasLines: lineFeatures.features.length > 0,
                groupingProperty: groupingProperty,
                lineFeatures: lineFeatures
            });

            if (lineFeatures.features.length > 0) {
                if (!map.getSource(sourceId + '-lines')) map.addSource(sourceId + '-lines', { type: 'geojson', data: lineFeatures });
                else map.getSource(sourceId + '-lines').setData(lineFeatures);
                
                if (!map.getLayer(lineLayerId)) { 
                     map.addLayer({ 
                         id: lineLayerId, 
                         type: 'line', 
                         source: sourceId + '-lines', 
                         paint: { 'line-color': ['get', 'color'], 'line-width': parseInt(state.visualSettings.lineWidth) }, 
                         layout: { 'visibility': state.linesVisible ? 'visible' : 'none' } 
                     });
                     
                     map.on('click', lineLayerId, (e) => {
                         e.originalEvent.stopPropagation(); 
                         const feature = e.features[0];
                         const name = feature.properties.Alimentador || feature.properties.name || 'Sem Nome';
                         const groupName = feature.properties[groupingProperty];
                         const currentColor = groupColorMap.get(groupName) || '#000000';
                         const popupContainer = document.createElement('div');
                         popupContainer.innerHTML = `<strong>${name}</strong><br><label style="font-size:12px;margin-right:5px">Mudar Cor:</label>`;
                         const colorInput = document.createElement('input');
                         colorInput.type = 'color'; colorInput.value = currentColor; colorInput.style.cursor = 'pointer';
                         colorInput.addEventListener('change', (ev) => applyColorUpdate(groupName, file.sourceId, ev.target.value));
                         popupContainer.appendChild(colorInput);
                         new maplibregl.Popup().setLngLat(e.lngLat).setDOMContent(popupContainer).addTo(map);
                     });
                     map.on('mouseenter', lineLayerId, () => map.getCanvas().style.cursor = 'pointer');
                     map.on('mouseleave', lineLayerId, () => { if (!state.isRoutePlanning) map.getCanvas().style.cursor = ''; });
                }
            }

            updateGroupMenu();
            updateLoadedFilesList(fileName);
            updateVisibleMarkers();
            if (!state.isOfflineMode) cacheKMZData(fileName, geojson);
        }

        function removeFileFromMap(fileName) {
            const fileIndex = state.files.findIndex(file => file.name === fileName);
            if (fileIndex === -1) return;
            const file = state.files[fileIndex];
            const sourceId = file.sourceId;
            allPointFeatures = allPointFeatures.filter(feature => feature.properties.fileName !== fileName);

            if (file.hasLines) {
                const lineLayerId = `lines-${sourceId}`;
                if (map.getLayer(lineLayerId)) map.removeLayer(lineLayerId);
                if (map.getSource(sourceId + '-lines')) map.removeSource(sourceId + '-lines');
            }
            if (file.hasLines && file.groupingProperty && state.selectedGroups.has(sourceId)) state.selectedGroups.delete(sourceId);
            const liToRemove = [...loadedFilesList.children].find(li => li.textContent.startsWith(fileName));
            if (liToRemove) liToRemove.remove();
            state.files.splice(fileIndex, 1);
            updateGroupMenu();
            updateVisibleMarkers();
        }

        function updateMarkerGroupMenu() {
            markerGroupsList.innerHTML = '';
            Object.keys(state.markerGroups).forEach(groupKey => {
                if (groupKey === 'default') return;
                const group = state.markerGroups[groupKey];
                const li = document.createElement('li');
                const lbl = document.createElement('label');
                lbl.style.display = 'flex'; lbl.style.alignItems = 'center'; lbl.style.width = '100%'; lbl.dataset.groupLabel = groupKey;
                const chk = document.createElement('input');
                chk.type = 'checkbox'; chk.checked = group.visible; chk.style.marginRight = '10px';
                chk.onchange = () => { state.markerGroups[groupKey].visible = chk.checked; updateVisibleMarkers(); };
                const textSpan = document.createElement('span');
                textSpan.textContent = groupKey; textSpan.style.fontWeight = 'bold'; textSpan.style.color = group.color; textSpan.style.flexGrow = '1';
                const colorInput = document.createElement('input');
                colorInput.type = 'color'; colorInput.value = group.color; colorInput.style.border = 'none'; colorInput.style.width = '30px'; colorInput.style.height = '25px'; colorInput.style.padding = '0'; colorInput.style.cursor = 'pointer'; colorInput.style.background = 'none';
                colorInput.addEventListener('input', (e) => { textSpan.style.color = e.target.value; changeMarkerGroupColor(groupKey, e.target.value); });
                colorInput.addEventListener('click', (e) => e.stopPropagation());
                lbl.appendChild(chk); lbl.appendChild(textSpan); lbl.appendChild(colorInput);
                li.appendChild(lbl); markerGroupsList.appendChild(li);
            });
        }

        function applyMarkerGroupFilter() { updateVisibleMarkers(); }
        function toggleAllMarkerGroups(visible) { Object.keys(state.markerGroups).forEach(groupKey => { state.markerGroups[groupKey].visible = visible; }); updateMarkerGroupMenu(); updateVisibleMarkers(); }
        function toggleMarkers(visible) {
            state.markersVisible = (typeof visible === 'boolean') ? visible : !state.markersVisible;
            toggleAllMarkersVisibilityCheckbox.checked = state.markersVisible;
            if (map.getLayer('dynamic-marker-circles')) map.setLayoutProperty('dynamic-marker-circles', 'visibility', state.markersVisible ? 'visible' : 'none');
            toggleNames(state.markersVisible && state.namesVisible);
        }
        function toggleNames(forceVisibility) {
            state.namesVisible = (typeof forceVisibility === 'boolean') ? forceVisibility : !state.namesVisible;
            if (map.getLayer('dynamic-marker-labels')) map.setLayoutProperty('dynamic-marker-labels', 'visibility', state.namesVisible ? 'visible' : 'none');
        }
        
        function updateGroupMenu() {
            lineGroupsList.innerHTML = '';
            state.files.forEach(file => {
                if (file.hasLines && file.groupingProperty) {
                    const selectedFileGroups = state.selectedGroups.get(file.sourceId) || new Set();
                    const fileHeader = document.createElement('div');
                    fileHeader.style.fontWeight = 'bold'; fileHeader.style.marginTop = '10px'; fileHeader.textContent = `Arquivo: "${file.name}"`;
                    lineGroupsList.appendChild(fileHeader);
                    const allFileGroups = new Set();
                    file.lineFeatures.features.forEach(feature => { if (feature.properties && feature.properties[file.groupingProperty]) allFileGroups.add(feature.properties[file.groupingProperty]); });
                    const sortedGroups = Array.from(allFileGroups).sort((a, b) => a.localeCompare(b));
                    sortedGroups.forEach(grp => {
                        const li = document.createElement('li');
                        const lbl = document.createElement('label');
                        lbl.style.display = 'flex'; lbl.style.alignItems = 'center';
                        const chk = document.createElement('input');
                        chk.type = 'checkbox'; chk.value = grp; chk.checked = selectedFileGroups.has(grp);
                        const groupColor = groupColorMap.get(grp);
                        if (groupColor) { lbl.style.color = groupColor; lbl.style.fontWeight = 'bold'; }
                        chk.onchange = () => { const currentGroups = state.selectedGroups.get(file.sourceId); if (chk.checked) currentGroups.add(grp); else currentGroups.delete(grp); applyGroupFilter(); };
                        lbl.appendChild(chk); lbl.appendChild(document.createTextNode(' ' + grp));
                        const colorPicker = document.createElement('input');
                        colorPicker.type = 'color'; colorPicker.value = groupColor || '#CCCCCC'; colorPicker.style.marginLeft = 'auto'; colorPicker.style.padding = '0'; colorPicker.style.border = 'none'; colorPicker.style.width = '30px'; colorPicker.style.height = '20px'; colorPicker.style.cursor = 'pointer';
                        colorPicker.dataset.groupName = grp; colorPicker.dataset.sourceId = file.sourceId;
                        colorPicker.onchange = handleColorChange; colorPicker.onclick = (e) => e.stopPropagation(); 
                        lbl.appendChild(colorPicker); li.appendChild(lbl); lineGroupsList.appendChild(li);
                    });
                }
            });
        }

        function updateLoadedFilesList(fileName) {
            const li = document.createElement('li'); li.textContent = fileName;
            const removeBtn = document.createElement('button'); removeBtn.textContent = 'Remover';
            removeBtn.addEventListener('click', () => removeFileFromMap(fileName));
            li.appendChild(removeBtn);
            const existingLi = [...loadedFilesList.children].find(child => child.textContent.startsWith(fileName));
            if (!existingLi) loadedFilesList.appendChild(li);
        }

        function applyGroupFilter() {
            state.files.forEach(file => {
                if (!file.hasLines || !file.groupingProperty) return;
                const lineLayerId = `lines-${file.sourceId}`;
                const selectedGroups = state.selectedGroups.get(file.sourceId);
                if (!map.getLayer(lineLayerId)) return; 
                if (!selectedGroups || selectedGroups.size === 0) map.setFilter(lineLayerId, ["==", file.groupingProperty, "___no_match___"]);
                else map.setFilter(lineLayerId, ["in", file.groupingProperty, ...Array.from(selectedGroups)]);
            });
        }

        function hideAllGroups() {
            state.selectedGroups.forEach((groups, sourceId) => state.selectedGroups.set(sourceId, new Set()));
            document.querySelectorAll('#lineGroupsList input[type=checkbox]').forEach(chk => chk.checked = false);
            applyGroupFilter();
        }

        function showAllGroups() {
            state.files.forEach(file => {
                if (file.hasLines && file.groupingProperty) {
                    const allGroups = new Set();
                    if (file.lineFeatures && file.lineFeatures.features) {
                        file.lineFeatures.features.forEach(feature => { if (feature.properties && feature.properties[file.groupingProperty]) allGroups.add(feature.properties[file.groupingProperty]); });
                        state.selectedGroups.set(file.sourceId, new Set(allGroups));
                    }
                }
            });
            document.querySelectorAll('#lineGroupsList input[type=checkbox]').forEach(chk => chk.checked = true);
            applyGroupFilter();
        }

        function toggleLines(visible) {
            state.linesVisible = (typeof visible === 'boolean') ? visible : !state.linesVisible;
            toggleAllLinesVisibilityCheckbox.checked = state.linesVisible;
            state.files.forEach(file => {
                if (file.hasLines) {
                    const lineLayerId = `lines-${file.sourceId}`;
                    if (map.getLayer(lineLayerId)) map.setLayoutProperty(lineLayerId, 'visibility', state.linesVisible ? 'visible' : 'none'); 
                }
            });
        }
        
        function resetView() { map.easeTo({ center: [-47.068847, -22.934973], zoom: 11 }); }

        function changeMapStyle(newStyleUrlOrObject) {
            map.setStyle(newStyleUrlOrObject);

            map.once('styledata', () => {
                if (!map.getSource('dynamic-markers')) {
                    map.addSource('dynamic-markers', {
                        type: 'geojson',
                        data: { type: 'FeatureCollection', features: [] }
                    });
                    dynamicMarkerSource = map.getSource('dynamic-markers');
                }

                if (!map.getLayer('dynamic-marker-circles')) {
                    map.addLayer({
                        id: 'dynamic-marker-circles',
                        type: 'circle',
                        source: 'dynamic-markers',
                        paint: {
                            'circle-radius': parseInt(state.visualSettings.markerSize),
                            'circle-color': ['get', 'color'],
                            'circle-stroke-width': 2,
                            'circle-stroke-color': '#FFFFFF'
                        }
                    });
                }

                if (!map.getLayer('dynamic-marker-labels')) {
                    map.addLayer({
                        id: 'dynamic-marker-labels',
                        type: 'symbol',
                        source: 'dynamic-markers',
                        layout: {
                            'text-field': ['coalesce', ['get', 'name'], ['get', 'Alimentador']],
                            'text-font': ['Open Sans Bold'],
                            'text-size': parseInt(state.visualSettings.textSize),
                            'text-offset': [0, 1.5],
                            'visibility': state.namesVisible ? 'visible' : 'none'
                        },
                        paint: {
                            'text-color': '#000000',
                            'text-halo-color': '#FFFFFF',
                            'text-halo-width': 2
                        }
                    });
                }

                state.files.forEach(file => {
                    if (file.hasLines) {
                        const sourceIdLines = file.sourceId + '-lines';
                        const lineLayerId = `lines-${file.sourceId}`;
                        
                        if (!map.getSource(sourceIdLines)) map.addSource(sourceIdLines, { type: 'geojson', data: file.lineFeatures });
                        if (!map.getLayer(lineLayerId)) {
                             map.addLayer({ 
                                 id: lineLayerId, 
                                 type: 'line', 
                                 source: sourceIdLines, 
                                 paint: { 'line-color': ['get', 'color'], 'line-width': parseInt(state.visualSettings.lineWidth) }, 
                                 layout: { 'visibility': state.linesVisible ? 'visible' : 'none' } 
                             });
                        }
                    }
                });

                state.files.forEach(file => {
                    if (file.hasLines) {
                        const lineId = `lines-${file.sourceId}`;
                        if (map.getLayer(lineId)) map.moveLayer(lineId);
                    }
                });

                if (map.getLayer('dynamic-marker-circles')) map.moveLayer('dynamic-marker-circles');
                if (map.getLayer('dynamic-marker-labels')) map.moveLayer('dynamic-marker-labels');

                updateVisibleMarkers();
                applyGroupFilter();
                toggleLines(state.linesVisible);
                toggleNames(state.namesVisible && state.markersVisible);
            });
        }

        function displayStyleList() {
            const styleList = document.getElementById('styleList');
            styleList.innerHTML = '';
            mapStyles.forEach(style => {
                const li = document.createElement('li');
                li.textContent = style.name;
                li.addEventListener('click', () => { changeMapStyle(style.url || style.style); styleMenu.style.display = 'none'; });
                styleList.appendChild(li);
            });
        }

        function normalizeText(text) {
             if (!text) return '';
             return text.toString().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/[^a-z0-9]/g, '');
        }

        function getFeatureCenter(feature) {
            if (!feature || !feature.geometry) return null;
            if (feature.geometry.type === 'Point') {
                if (feature.geometry.coordinates.length >= 2) return feature.geometry.coordinates;
                return null;
            }
            let coords = [];
            const extract = (list) => {
                if (Array.isArray(list[0])) list.forEach(extract);
                else if (list.length >= 2 && typeof list[0] === 'number') coords.push(list);
            };
            extract(feature.geometry.coordinates);
            if (coords.length === 0) return null;
            const avgLng = coords.reduce((sum, p) => sum + p[0], 0) / coords.length;
            const avgLat = coords.reduce((sum, p) => sum + p[1], 0) / coords.length;
            return [avgLng, avgLat];
        }

        async function searchFeatures() {
            const term = searchInput.value.toLowerCase().trim();
            if (!term) return alert('Digite um termo para buscar.');
            const matches = allPointFeatures.filter(f => {
                const name = f.properties.name || f.properties.Alimentador || '';
                return normalizeText(name).includes(normalizeText(term));
            }).slice(0, 15);
            displaySearchResults(matches);
        }

        function displaySearchResults(results) {
            searchResults.innerHTML = '';
            if (results.length === 0) {
                 searchResults.style.display = 'none';
                 return alert('Nenhum resultado encontrado.');
            }
            const ul = document.createElement('ul');
            results.forEach(result => {
                const li = document.createElement('li');
                const name = result.properties.name || result.properties.Alimentador || 'Sem nome';
                const fileName = result.properties.fileName || '';
                
                const infoDiv = document.createElement('div');
                infoDiv.className = 'result-info';
                infoDiv.innerHTML = `<strong>${name}</strong><br><small style="color:#666">${fileName}</small>`;
                
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'result-actions';

                const btnVer = document.createElement('button');
                btnVer.textContent = 'Ver';
                btnVer.onclick = (e) => {
                    e.stopPropagation();
                    const center = getFeatureCenter(result);
                    if(center) { map.flyTo({ center: center, zoom: 16 }); searchResults.style.display = 'none'; } 
                    else { alert('Localização inválida.'); }
                };

                const btnRota = document.createElement('button');
                btnRota.textContent = 'Rota';
                btnRota.style.backgroundColor = '#34A853'; 
                btnRota.onclick = (e) => {
                    e.stopPropagation();
                    const center = getFeatureCenter(result);
                    if (center) {
                        const url = `https://www.google.com/maps/dir/?api=1&destination=${center[1]},${center[0]}&travelmode=driving`;
                        window.open(url, '_blank');
                    } else { alert('Coordenadas inválidas.'); }
                };

                actionsDiv.appendChild(btnVer);
                actionsDiv.appendChild(btnRota);
                li.appendChild(infoDiv);
                li.appendChild(actionsDiv);
                ul.appendChild(li);
            });
            searchResults.appendChild(ul);
            searchResults.style.display = 'block';
        }

        function computeDistance(coord1, coord2) {
             const toRad = (value) => value * Math.PI / 180;
             const R = 6371e3; 
             const φ1 = toRad(coord1[1]), φ2 = toRad(coord2[1]);
             const Δφ = toRad(coord2[1] - coord1[1]), Δλ = toRad(coord2[0] - coord1[0]);
             const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
             return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        function goToCurrentLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition((pos) => {
                    const coords = [pos.coords.longitude, pos.coords.latitude];
                    state.userLocation = coords;
                    map.flyTo({ center: coords, zoom: 16 });
                    new maplibregl.Marker({ color: 'blue' }).setLngLat(coords).addTo(map);
                }, () => alert('Erro ao obter localização.'));
            } else alert('Geolocalização não suportada.');
        }

        function toggleRoutePlanning() {
            state.isRoutePlanning = !state.isRoutePlanning;
            if (state.isRoutePlanning) {
                routePanel.style.display = 'flex';
                btnRoutePlanner.classList.add('active');
                map.getCanvas().style.cursor = 'crosshair';
                updateRoutePanelUI();
            } else {
                cancelRoutePlanning();
            }
        }

        function addWaypointToRoute(feature) {
             if (routeWaypoints.length >= MAX_WAYPOINTS) return alert('Máximo de pontos atingido.');
             const coords = feature.geometry.coordinates.slice();
             const name = feature.properties.name || 'Ponto';
             routeWaypoints.push({ name: name, coordinates: coords });
             const m = new maplibregl.Marker({ color: '#f7b731' }).setLngLat(coords).addTo(map);
             routeMarkers.push(m);
             updateRoutePanelUI();
        }

        function updateRoutePanelUI() {
             routeList.innerHTML = '';
             routeWaypoints.forEach((wp, i) => {
                 const li = document.createElement('li');
                 li.innerHTML = `<span>${wp.name}</span> <button class="remove-wp" onclick="removeWaypoint(${i})">X</button>`;
                 routeList.appendChild(li);
             });
             routeCounter.textContent = `Pontos: ${routeWaypoints.length} / ${MAX_WAYPOINTS}`;
        }
        
        window.removeWaypoint = function(index) { 
             routeWaypoints.splice(index, 1);
             if(routeMarkers[index]) routeMarkers[index].remove();
             routeMarkers.splice(index, 1);
             updateRoutePanelUI();
        };

        function cancelRoutePlanning() {
             routeMarkers.forEach(m => m.remove());
             routeMarkers = [];
             routeWaypoints = [];
             updateRoutePanelUI();
             routePanel.style.display = 'none';
             state.isRoutePlanning = false;
             btnRoutePlanner.classList.remove('active');
             map.getCanvas().style.cursor = '';
        }

        function generateGoogleMapsUrl() {
             if (routeWaypoints.length < 1) return alert("Adicione pontos.");
             const dest = routeWaypoints[routeWaypoints.length - 1];
             let url = `https://www.google.com/maps/dir/?api=1&destination=${dest.coordinates[1]},${dest.coordinates[0]}&travelmode=driving`;
             if (routeWaypoints.length > 1) {
                 const wps = routeWaypoints.slice(0, -1).map(wp => `${wp.coordinates[1]},${wp.coordinates[0]}`).join('|');
                 url += `&waypoints=${wps}`;
             }
             window.open(url, '_blank');
             cancelRoutePlanning();
        }

        const menuButtons = document.querySelectorAll('.menu button');
        menuButtons.forEach(button => {
            button.addEventListener('mouseover', () => { const l = button.querySelector('.button-legend'); if (l) l.style.display = 'block'; });
            button.addEventListener('mouseout', () => { const l = button.querySelector('.button-legend'); if (l) l.style.display = 'none'; });
        });
    </script>
</body>
</html>